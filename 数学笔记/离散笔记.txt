"注释: | 为整除符号 表示 a|b  a可以整除b ,比如 4|2 =2 结果是整数.

---------------------------基础知识----------------------------------------

欧几里得算法 {
	当不知道整数a和b的因子分解时,也可以计算a和b的最大公因子.
	欧几里得在《几何原本》中提出了计算最大公因子的算法,这被公认是最早的算法,也是人类历史上最美丽的算法之一.
	在表述该算法之前,先给出下述定理,奠定算法的理论基础:
*定理
	设 a=qb+r, 其中a,b,q,r 都是整数,则
			GCD(a,b) = GCD(b,r)
		a和b的最大公因子就等于b和r的最大公因子,在这过程中a,b二者的最大值一定大于等于b,r二者的最大值的.
		a,b的因子集合等于b,r的因子集合,因子集合相同,那么其中的最大值也相同.
*证明	
	若 d|a 且 d|b,则有 d|b 且 d|r
	若 d|b 且 d|r,则有 d|(qb+r),即 d|a
	于是,a与b的公因子集合和b与r的公因子集合相同.继而,最大公因子相同.

	欧几里得算法(辗转相除法) GCD(a,b).
	输入:整数a,b ,满足a ≥ b ≥ 0 ,且a,b不全为0.
	输出:GCD(a,b) 他们的最大公因子
step1	if b=0 then return a			判断b是不是等于0,若等于0则直接输出a
step2	Else return GCD(b,a mod b)		计算a除以b的余数,就是之前定义中表示的r,调用自己计算b和r的最大公因子集合,这是一个自己调用自己的算法,这是一个递归算法,而且每次调用自己的算法的时候,问题的规模都在降,之前输入是a,b 输入的最大值是a,这次输入的是b和r,其中的最大值是b,是小于等于a的,问题的规模还在降,事实上证明算法一定会终止.

		其中,若 a=q·b+r 且 0 ≤ r ≤ b
		则定义 a mod b = r


*例题(辗转相除法)
	计算GCD(210,715)的最大公因子.	(每次都是大值除以小值,直到其中一个是0)
		a=210		b=715		b/a的余数r	715=3*210+85	余数替换b
		  210		  85		a/b的余数r	210=2*85+40		余数替换a
		  40		  85		b/a的余数r	85 =2*40+5		余数替换b
		  40		  5			a/b的余数r	40 =8*5+0		余数替换a
		  0			  5			得到其中一个为0时,最大公约数为5
		GCD(715,210) =5
	由此题反向推理裴蜀等式:
	最大公因子5;
	5=85-2*40		=85-2*(210-2*85)
	 =5*85-2*210	=5*(715-3*210)-2*210
	 =5*715-17*210
	在这个例子中,最大公因子便是成了两个输入的值的整系数的线性组合,这不是巧合
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

裴蜀等式{
	对于不全为0的整数a,b和d,方程 sa+tb=d 存在整数解s和t当且仅当GCD(a,b)|b.a,b的最大公因子可以整除d.
	这个方程 sa+tb=d 称作裴蜀等式,或贝祖等式.(是一个数论中的基本的重要结果)

*证明
	(充分性) 通过上个例题回带法的例子,可知 sa+tb=GCD(a,b)存在整数解,设其为s₀,t₀ 
	若 d=k·GCD(a,b) ,则 k·s₀ ,k·t₀ 是方程的一个解.
	(必要性) 若方程 sa+tb=d 存在整数解s 和t 则 GCD(a,b)|(sa+tb)=d
	
*例题
	15s + 21t = 3
	解	15·(-4)+21·3=3		15和21最大公因子是3,而3可以整除3,有整数解.
	
	22s + 34t = 9
	解	不存在整数解		22和34最大公因子是2,而9不可以整除2,无整数解.

	21s + 28t =14
	解	21·(-2)+28·2=14		21和28最大公因子是7,而14可以整除7,有整数解.

	5s + 8t = 1
	解	5·(-3)+8·2=1		没有最大公因子但是可以整除

	6s + 8t = 4
	解	6·2+8·(-1)=4		没有最大公因子但是可以整除

	一定要向上推倒,解可以求解.
	最小公倍数 LCM 计算公式为, LCM(a,b) = (a * b) / GCD(a ,b)
	就是两数的乘积除以两数的最大公约数,即可等于最小公倍数.
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

*同余{
	设 n 是正整数,a 和 b 是整数,如果 n|(a-b) ,则称a模n同余于b,或 a与b模n同余,记作 a ≡ b(mod n), n 称为模 (modulus).
*例	70 ≡ 5(mod 13)		表示 70-5 等于 65 可以被 13 整除
   -19 ≡ 6(mod 25)		表示 -19-6等于-25 可以被 25 整除

   等价于代码 70 % 13 = 5;
*定理
	以下命题等价
		(1) a 与 b 模 n 同余;
		(2) a mod n = b mod n;
		(3) a = b+kn, 其中 k 是整数.
	*注意: b|a 当且仅当 a mod b = 0 .
*定理
	若a ≡ b(mod n), c ≡ d (mod n), 则
		a ± c ≡ b ± d (mod n),
		   ac ≡ bd (mod n).
 
	*一些方便的计算方式(个人总结)
		a ≡ b(mod n)
		解	(a+b)|n  如果可以整除n 那么这个mod正确,否则不正确.


}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

*加法法则与乘法法则{
	*加法法则:
		设事件 A 有 m 种产生方式,事件 B 有 n 种产生方式,则当A与B产生的方式 不重叠 时,“事件A或B之一” 有m+n 种产生方式.
		加法法则又称 加法原理.
		它们适用于分类选取问题,分为 A 和 B.
	*例
		某班选修《古代诗歌鉴赏》的有8人,不选的有15人,则该班共有8+15=23人.
	
	*乘法法则:
		设事件 A 有 m 种产生方式,事件 B 有 n 种产生方式,则当A于B产生的方式 彼此独立 时,“事件A于B” 有 m·n 种产生方式.
		乘法法则又称乘法原理.
		适用于分布选取问题.
		使用条件:
			无论事件A采用何种方式产生,都不影响事件B.
	
	*例
		a)例如一个实验分两步骤进行:
			(1)步骤一有 m 种可能结果.
			(2)无论步骤一的结果是什么,步骤二都有n种可能结果.
			(3)那么这个实验就共有 m*n 种可能的结果.

		b)某种字符串由两个字符组成,第一个字符可选自{a,b,c,d,e},第二个字符可选自{1,2,3,4},则这种字符串共有 5*4=20 个.
		
		c)求1400 的不同的正因子个数.
			解	1400=2³ 5² 7¹ 的正因子为: 2^i 5^j 7^k
				其中 0 ≤ i ≤ 3, 0 ≤ j ≤ 2, 0 ≤ k ≤ 1
				于是, 1400 的不同的因子数时 
					N = (3+1)(2+1)(1+1)=24
		
		d)设A时集合,如果|A|=n ,则|∱(A)|=2^n (A中幂集的元素数).
			证明:
				假设A={a₁,a₂,a₃,...,an}(第n个a)
				考虑A的任一个子集B
				则对于每一个元素ai(第i个a),都有ai∈B和ai∉B两种可能
				由乘法原理,B的可能数目一共为 2^n 

		在实际问题中,分类(加法原则)与分步(乘法原则)通常都结合使用.
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

*排列{
	问题: 设集合S包含n个元素,从S中选取r个元素有多少种取法?
		解 根据“取出的元素是否允许重复”,“取出的过程是否有序”可以将问题分为四个子类型:

			     不重复选取     重复选取				特殊
		有序选取	排列		可重排列		限制次数的可重排列
		无序选取	组合		可重组合

	从 n 个不同的对象中,取r个可重复的对象,按次序排列,称为n取r的    可重排列.(两个要素,一 元素可以重复,二 有先后次序的区别)
	此也即当|A|=n时(A有n个元素师),A*(就是A上所有元素可能组成的有限长度序列全体)其中长为r的串的个数,有就是序列的个数.

	*定理1
		n取r的可重排列数目为n^r .

排列
	从n个不同的对象中,取n个不重复的对象,按次序排列,称为 n取r的排列.n取r排列的全体构成的集合用 P(n,r)表示(正P), 排列的个数用𝑷 (n,r)表示(斜𝑷).
	当r=n 时称为全排列或置换.
	此也即当|A|=n 时,A* 中长为r且各项彼此不同的串的个数.
	例如:	A={a,b,c,d}
			A上的所有4取3的“排列”有24 种,比如:
				abc, bac, acb, bca, cab, cba, abd, bad, adb, bda,
				dba, bcd, bdc, cbd, cdb, dbc, dcb, acd, adc, cad,
				cda, dac ,dca, dba
			A上的“全排列”同样有24种,比如:
				abcd, abdc, acbd, adbc, adcb, dacd, badc, dcab...

*定理2
	n < r时,𝑃 (n,r) = 0;
	n ≥ r时,𝑷 (n,r) = n·(n - 1)·...·(n - r + 1)

	全排列经常被理解为是“包含某个有限集合中的所有元素一次且仅一次的序列“.
	设A是集合,如果|A| = n,(A中有n个元素),则A的全排列的个数为:
				n·(n-1)·...·1
	这个值也经常被写作 n! ,称作 n 的 阶乘.
	
	使用 阶乘可以给出 𝑃 (n,r)的一个更紧凑的表达式:
	𝑷 (n,r) =n·(n-1)·(n-2)·....·(n-r+1)
			 n·(n-1)·(n-2)·....·(n-r+1)·(n-r)·(n-r-1)·...·2·1
			=------------------------------------------------(分式)
						(n-r)·(n-r-1)·...·2·1
				n!
计算公式  𝑷 =-——------		(结果是n的阶乘除以n-r的阶乘)
			  (n-r)!

*例	
	一个社团共有10名成员,从中选出一名主席,一名副主席,一名书记,则共有𝑷 (10,3)=720 种方法.(过程:10*9*8...*1=3628800,(10-3)=7,7*6*5...*1=5040,3628800/5040=720)

}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

*排列 2 { ( 限制次数的可重排列,特殊的可重复排列 )	

*定理
	由k₁ 个符号1,k₂ 个符号2,..., kt 个符号t 组成的长度为 n 的排列总数为:
					 n!
				-------------
				k₁!·k₂!...kt!
		其中 n = k₁ + k₂ + ... kt 


*例1
	先考虑一个类型的简单问题——
	由 a,a,b,c 可以组成多少个长度为4的字符串?
			4! /2! = 12 个
	由 a,a,a,b 可以组成多少个长度为4的字符串?
			4! /3! = 4 个
	由 a,a,b,b 可以组成多少个长度为4的字符串?
			4! /(2!·2!) = 6 个

*例2
	由 a,b,b,e,e,h,i,s,s,h,h,h 可以组成多少个长度为 12 的字符串?
	解:	12! / ( 1! · 2! · 2! · 1! · 1! · 2! · 3!) = 9979200 种组合.




}



&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

*组合{
	
	问题: 设集合S包含n个元素,从S中选取r个元素有多少种取法?
		解 根据“取出的元素是否允许重复”,“取出的过程是否有序”可以将问题分为四个子类型:

			     不重复选取     重复选取
		有序选取	排列		可重排列
		无序选取	组合		可重组合

	从 n 个不同元素中取 r 个不重复的元素组成一个子集,而不考虑其他元素的顺序,称为 n 取 r 的组合,该子集称作 r -子集 .n取r 组合的全体构成的集合用 C (n,r) 表示,其元素个数用 𝘾 (n,r) 表示,有时也记作 ( n )
										  (	r ) 其实这两个在一个括号里!
		当n ≥ r 时	C ( n,r ) = C ( n , n -r )
		n 是总集合, r 是需要收集元素的个数
		
*例
	一个社团共有 10 名成员,从中选出 3 人组成指导委员会, 则共有 𝘾 (10,3) =120种方法.	(注意和“排列”进行比较).


*公式
		𝘾 ( n , r ) · r! = P ( n. r )
		组合 乘以 r 的阶乘(r=比如 4选3 中的 3), 才可以等于组合.
		排列 的计算方式是 n 的阶乘 除以 n-r 的阶乘.(r是 n-r 之后剩下的值).

		
			        𝑷 ( n,r )		   n!
*计算公式  𝘾 ( n,r) =--------- = --------------
				        r!  	   (n - r)! · r!
		计算公式,当 n ≥ r 才可行.


*特殊例题	
		由 a,b,b,e,e,h,i,s,s,t,t,t 可以组成多少个长度为 12 的字符串?
		解:
			可以想像成把这12个字符放入12个空白位置,如果先放 t 那么会有		𝘾 (12,3), 剩下 9个空白位置 , 选择两个位置再次放置 s ,会有𝘾 ( 9,2 ), 选择2个放置 e , 𝘾 ( 7,2 ), 选择两位置放置 b ,𝘾 ( 5,2 ), 最后剩下三个空白位置,还剩下 i h a 三个字符,将这三个字符进行全排列之后 放入这三个空白位置,也就是 3! (3的阶乘)种可能性, 所以总的填写的组合有:
			𝘾 ( 12,3 ) * 𝘾 ( 9,2 ) * 𝘾 ( 7,2 ) * ( 5,2 ) * 3! 
			= 9979200  种可能;
			可以得到相同结果;
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

*组合2 { (可重组和:选取过程无序,选取元素可以重复)
	
*定理 n 取 k 的可重组合
	  假设从 n 个相异对象中选取 k 个对象,且允许重复选取,则不同的选取方法数目为 𝘾 ( n + k - 1 , k) .


*例1
	现在有四种口味的棒棒糖,你要从中选3个(允许你选择同一种口味3次).总共有多少种不同的选法?
	解:
		口味1的棒棒糖 x₁ 个.
		口味2的棒棒糖 x₂ 个.
		口味3的棒棒糖 x₃ 个.
		口味4的棒棒糖 x₄ 个.
		x₁,x₂,x₃,x₄ 的值都是非负整数,而且满足等式 x₁ + x₂ + x₃ + x₄ = 3 .
	方程的一组解:
	例如:	x₁ = 2, x₂ = 0, x₃ = 1, x₄ =0 
		𝘾 ( 6,3 )
		6 是 棒棒糖+ 口味数 -1	
		3 是 棒棒糖数
	
*例2
	如果从{ A , B ,C }中选择 4 个字母并且允许重复,则共有多少种选择方案?
	解:	套公式 𝘾 ( n + k -1 , k)
		n = 3 , k = 4 
		𝘾 ( 3 + 4 -1 , 4) = 𝘾 ( 6 ,4 ) = 6! / [(6 - 4) * 4!] =  15 
		总共有 15 种方案.

}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

(组合 2,2)鸽巢原理{
	鸽巢原理 是组合数学中最简单也是最基本的原理,也称作 狄利克雷抽屉原则 .  因为狄利克雷 首先明确提抽屉原则并用以证明一些数论中的问题.
	
	抽象来讲,比如有 9 个鸽子巢,但是有 10只鸽子,那么必定有1个鸽巢中有两只鸽子.

*定理 (鸽巢原理)
	若有 n 个鸽巢, n+1 个鸽子,则至少有一个巢内用至少两个鸽子.

*例1
	假设在一个盒子里面有 10 双 黑色袜子,12双蓝色袜子和 8双红色袜子.那么拿出4只袜子一定可以保证有同色的两只.
	在这个问题中:  每种颜色作为抽屉, 有三个;
				   拿出的袜子数目作为苹果,有四个;
				所以一定会有一种颜色至少拿出来了两只袜子.

*例2 
	在 1 到 10 中选取 6 个数,则其中必定有两个数的和是 11.
		证明:
			我们把 1 到 10 当中和为11的所有数字挑选出来,分为5组,形成五个集合
			{1,10}, {2,9}, {3,8}, {4,7}, {5,6}. 这五个集合就是五个抽屉.
			我们要取得的六个数就看作是 6 个苹果, 那么一定有一个盒子中,有两个苹果,换句话说,一定有一个集合中两个数字都被取到了.

*例3
	任意12个整数中一定存在两个整数,其差是11的倍数.
		证明:
			任何一个整数模11的余数都只有11种:0,1,2,3...,10;
			于是任意的12个整数中,必定存在两个整数模11的余数相同,
			他们的差就是11的倍数.
		
*定理( 一般性鸽巢原理 )
	设 m₁,m₂,...,mn 都是正整数,并有 m₁+m₂+...+mn-n+1 只鸽子住进 n 个鸽巢,则至少对某个 i 有: 第 i 个鸽巢中至少有 mi 个鸽子,i=1,2,...,n.

*推论
	m 只鸽子住进 n 个巢,且 m-1=q·n+r ,其中q和r是整数,且 0 ≤ r ≤ n. 则至少有一个巢里有 q+1 只鸽子.

*例4
	如果小张在 15 天内做了170 道习题,那么他一定有某一天做了至少12 道习题.
	证明:
		170-1 = 169 = 11 * 15 + 4
		相当于 169 % 15 = 11 + 4   169 模 15
		也就是 11 + 1 =12 那么就是说至少有一天做了至少12道习题.

*例5
	在一个边长为 1 的正六边形中任何放置 19 个点,则其中必定有两个点之间的距离不超过 √3
	  ---- .
		3

}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

*容斥原理(有限集合技术){ (***  |A| 表示 A 集合中元素的个数,而不是有什么 )
	A = { 0,1,2,3}, B = {1,3,5,7,9}
	A ∪ B = { 0,1,2,3,5,7,9}
	A ∩ B = {1,3}
   |A ∪ B| = 7		数一数 |A ∪ B| 当中有 7 个元素
   |A ∩ B| = 2		数一数 |A ∩ B| 当中有 2 个元素
   |A| = 4 , |B| = 5	|A| 中有 4个元素 , |B| 中有 5个元素
   |A|+|B| - |A ∩ B| = 4+5-2 = 7 = |A ∪ B|	
   A + B 元素的个数是 9 ,减去 A 交 B 中元素的个数,就等于 A 交 B 中元素的个数

*定理
	设 A,B 为两个有限集, 则 |A ∪ B| = |A| + |B| - |A ∩ B| .
*证明
	显然,若 A 和 B 没有共同的元素,即 A ∩ B = ∅ ,则 |A ∪ B| = |A| + |B|.
	(这就是加法法则的集合论表示方法.)
	若 A ∩ B ≠ ∅ ,由 A ∪ B =(A - B) ∪ B 且 (A - B) ∩ B = ∅ ,
	及 A = (A - B) ∪ (A ∩ B)  且 (A - B) ∩ (A ∩ B) = ∅  ,有
	|A ∪ B| = |A — B| + |B| 及 |A| = |A - B| + |A ∩ B| ,即
	|A ∪ B| = |A| + |B| - |A ∪ B|.
	上述定理称作容斥原理.
	
*例1
	有多少个以“1” 开始或以 “00”结尾的长度为 8 的 0-1 序列?
	解:
		以 “1” 开始的长度为8的 0-1 序列有 2⁷ = 128 个;
		以 “00”结尾的长度为8的 0-1 序列有 2⁶ = 64  个;
		以 “1” 开始且以“00”结尾的长度有8的 0-1 序列有 2⁵ = 32 个;
		由容斥原理,满足题意的序列有
			128 + 64 -32 = 160 个

*例2
	设一个班里有40个学生，在第一次考试中有28人得到A，在第二次考试中有21人得到A，如果两次考试中都没有得到A的学生是5人，那么有多少名学生在两次考试中都得到A？
	解: 40 - 28 = 12 (第一次考试有 12 人没有拿到 A)
		12 - 5  = 7  (因为有 5 人两次都没拿到 A,所以有 7人第二次考到A)
		21 - 7  = 14 (第二次考试有 21 人得到A ,其中 7 个人第一次没有拿到A,算出有 14 人两次都得到 5分)
		40 - 14 - 5 = 21 (把两次得活不得5分的减去,算出有19人只有一次得A)
	结论:		只有14人两次都拿到了A

	
*	容斥原理可以推广到三个有限集元素的计数问题:
*定理:
	设 A,B,C 是有限集合,则:
		|A ∪ B ∪ C| = |A|+|B|+|C| -|A ∩ B| -|B ∩ C| -|A ∩ C| +|A ∩ B ∩ C|


*证明
	|A ∪ B ∪ C|
   =|A| + |B ∪ C| - |A ∩ (B ∪ C)|
   =|A| + |B ∪ C| - |(A ∩ B) ∪ (A ∩ C)|
   =|A| + |B| + |C| - |B ∩ C| - (|A ∩ B| + |A ∩ C| - |(A ∩ B) ∩ (A ∩ C)|) 
   =|A| + |B| + |C| - |B ∩ C| - (|A ∩ B| + |A ∩ C| - |(A ∩ A) ∩ (B ∩ C)|)
   =|A| + |B| + |C| - |A ∩ B| - |B ∩ C| - |A ∩ C| + |A ∩ B ∩ C|



*例3 
	某班有50名学生，其中养猫的有21人，养鱼的有22人，养狗的有23人，同时养猫和养鱼的有9人，同时养猫和养狗的有8人，同时养鱼和养狗的有7人，还有5人什么宠物也不养，那么同时养三种宠物的人数为多少?
	解:	应用定理 
	|A ∪ B ∪ C| = |A|+|B|+|C| -|A ∩ B| -|B ∩ C| -|A ∩ C| +|A ∩ B ∩ C|
	将数值带入:		将同时养三种宠物的人设成 x ,(也就是 |A ∩ B ∩ C|)
	50 -5 = 21 + 22 + 23 - 9 -8 -7 + x
	   45 = 66 - 9 - 8 - 7 + x
	   45 = 42 + x
	    3 = x
	同时养三种宠物的人数是 3 人.

}

------------------------------基础知识结束---------------------------------


------------------------------ 命题逻辑 -----------------------------------

*命题逻辑{
	logic ,源于希腊语, 是指 “推理的 艺术与科学”.
	有效与正确的推理的规则的形式化系统研究.
	
*命题,逻辑
	非真即假的陈述句称为命题.
	一个命题如果是对的或正确的,则称为真命题,其真值为“真”(true),常用 T 或 1 表示;
	一个命题如果是错的或不正确的,则称为假命题,其真值为“假”(false),常用 F 或 0 表示;
	悖论不是命题,他没有确定的唯一的真值.

	通常用小写英文字母 p,q,r...或带有下标的小写字母 p₁,p₂,p₃... 来表示命题,称为 命题变元 或 命题变项.
	严格来讲,命题变项与命题不同:
	1.	命题具有的含义和确定的真值.
	2.	而命题变项只有明确表示某个命题才有具体的含义和确定的真值.
	3.	命题变项那个一般只表示一个抽象的命题,其真值可能在 T 也可能是 F.
	通常也简称 命题变项 为 命题.

	不能在分解的命题称为 简单命题 或 源自命题.
		一般形式是 “...是...”
	由原子命题组合而成的命题称为复合命题.
	例如:	𝛑 和 𝘦 都是无理数.
			6 和 8至少有一个是合数.
			说刘老师讲课不好是不正确的.

	将命题链接起来的方式叫做 命题连接词 或 命题运算符 , 主要有以下几种:
		否定词(not):	~𝘱
		合取词(and):	𝘱 ∧ 𝑞 
		析取词(or) :	𝑝 ∨ 𝑞
		异或词	   :	𝘱 ⊕ 𝑞
		蕴含词	   :	𝘱 ⇒ 𝑞
		等价词	   :	𝘱 ⇔ 𝑞


p~:	设 𝘱 为命题,否定词 “ ~ ” 是一元链接词.
		~ 𝘱 读作 “ 非p ” 或 “ p的否定”.
		若 p 的真值为真,则 ~p 的真值为假; 繁殖 , 若 p 为假,则 ~p 为真.
		否定链接词的含义相当于自然语言中的 “不”,“没有”,“无”,“否定”,“取反”等.
	例:		用 p 表示命题 “ 3 是素数 ”.
				则 ~ p 即为命题 “ 3不是素数” .

p∧q: 设 p , q 为命题,合取词 “ ∧ ” 是二元链接词.
		p ∧ q 读作 “ p 与 q ” 或 “ p , q 的合取 ”.
		当且仅当 p , q 的真值均为真时, p ∧ q 的真值为真.
			相当于 p &&  q .
	例:		p 表示命题 “ 3是素数”.
			q 表示命题 “ 5是素数”.
			则 “ 3和5都是素数” 可是表示为 p ∧ q.

p∨q: 设 p,q 为命题,析取词 “ ∨ ”是二元链接词.
		p ∨ q 读作 “ p 或 q” 或 “ p,q 的析取 ”.
		当且仅当 p,q 的真值均为假时,p ∨ q 的真值为假.
			相当于 p || q .
	 例:	(a)苗苗在看电视或者吃饭.	(看电视和吃饭可以同时完成)
			(b)苗苗今天上午十时在清华大学或者在北京大学.  (不可以同时完成)
		通常称命题 (a) 种的“或者” 为 “可兼或”, 命题(b)中的“或者”为不可兼或“.
		自然语言中“可兼或”与析取联结词 ∨ 对应, 而“不可兼或”与亦或联结词对应.
		
p⊕q: 设 p,q 为命题,异或词“ ⊕ ”是二元链接词.
		p ⊕ q 读作 “ p 异或 q ”.
		当且仅当 p,q 的真值相同时,p ⊕ q的真值为假.
		“异或” 也称 “不可兼或”.
			相当于 p ^ q 
	
p⇒ q:设 p,q 为命题,蕴含词 “ ⇒ ”是二元联结词.
		p ⇒ q 读作 “若p 则 q” 或 “ p 蕴含 q ”
		当且仅当 p 的真值为真, q 的真值为假时, p ⇒ q 的真值为假.其他情况都是真.
		p 称作 前提 , q 称作 结论.
		蕴含联结词含义相当于自然语言中的 “如果p,则q”,“因为p,所以q”,“只要p,就q”,“只有q,才p”,“仅当q,则p”,“既然p,那么q”等.
	例:	p表示命题“今天晴”
		q表示命题“苗苗去图书馆”
		则“因为今天晴,所以妙妙趣图书馆了”可以表示 p ⇒ q .
	例:	p表示命题“2+2=4”
		q表示命题“北京是中国的首都”
		则 p ⇒ q 表示“因为 2+2=4 ,所以北京时中国的首都” 为真,  因为p 为真,q也为真,虽然没有任何逻辑,但是他形式上成立,并不是语义上的.

	对于p ⇒ q,当 p 为假时, q 不论为真为假,蕴含式的真值均为真.
		只有 p 真,q 假 这一种情况,该蕴含式才为假!! 剩下全是真.
	例:	“如果周五地震,那么下次课考试”.
		如果前提为假,周五没地震,那么无法判断下次课会不会考试,所以当 p 为假的时候,结论无论真假,该蕴含式都是真.

		对于命题 p ⇒ q ,称命题“p⇒ q” 为其逆命题,  命题“~p⇒ q”为其否命题.
						  命题“~p⇒ q”为其逆否命题.
		命题“p⇒ q” 只有 p 真, q 假 这一种情况,蕴含式才为假!!剩下全是真.

p⇔ q: 设 p,q 为命题,等价词“ ⇔ ” 是二元链接词.
	p⇔ q 读作 “p 当且仅当 q” 或 “p,q 等价”.
	当且仅当 p,q 的真值相同 时,p ⇔ q 的真值为真,其余全是假.
	“等价”也称为 “双条件”.
	等价联结词的含义相当于自然语言中的“p,当且仅当q”, “p是q的充分必要条件”,“ p , q 含义相同”等.
例:	p 表示“ 3 是奇数”
	q 表示“ 太阳从东方升起 ”
	则命题“3是奇数,当且仅当太阳从东方升起” 可符号化为p⇔ q,虽然这两句话没有内在联系,但是这个命题的真值是 真.


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

*命题公式及其分类{
	复合命题是由命题变项(字母),逻辑联结词(∧∨ ⊕ ⇒ ⇔ ) 和 括号 等符号组成的符号串;但 反过来,有这些符号组成的符号串并不一定都是命题.
	
	命题逻辑中的命题公式(简记为 wff) 递归地定义为:
	(1)单个命题变项 p,q,r,... 是命题公式.
	(2)如果A 是命题公式, 则 (~A) 也是命题公式.
	(3)如果A 和B 是命题公式,则由逻辑联结词 联结A 和B 的符号串也是命题公式.
		如: (A ∧ B),(A ∨ B),(A ⇒ B),(A ⇔ B) 等等.
	(4)有限次应用(1)-(3)构成的符号串才是 命题公式.

	换言之,只有用命题公式表示的符号串才是命题.命题公式也称合式公式,简称公式.

*规定:为简化公式的形式,作如下规定:
		(1) 优先级 ~,( ∧, ∨),(⇒ , ⇔ ). 括号内优先级相同,不遵循从左向右原则.
		(2) 公式(~p) 的括号可以省略,写成 ~p .
		(3) 整个公式最外层的括号可以省略.
例1
	(((~p)∧ q)⇒ (q ∨ p))
	化简成: ~p ∧ q ⇒ q ∨ p  首先计算 ~p ,然后计算 ∨ 和 ∧ ,最后计算 ⇒ .

例2
	p ∧ q ∨ r 不是命题公式.
	这个不是命题公式的简写,∧和∨计算顺序不分先后,所以应该写成(p∧q) ∨ r 或     p ∧ ( q  ∨ r ).

	
定义: 设A 为命题公式,B 为A 中的一个连续的符号串,且B 为命题公式,则称B 为A 的子公式.
例1		p ∨ q, q ∨ r,q ∧(q ∨ r)	
	都是命题公式 (p ∨ q) ⇒ (p ∧(q ∨ r)) 的子公式.
			
	而 p ∧ (q , q) ⇒ ( p 都不是该公式的子公式,因为他们本身不是公式.


定义: 命题公式不是命题,只有当公式中的每一个命题变项都被赋予确定的真值时,公式的真值才被确定,从而成为一个命题.
	如果一个命题公式A 含有 n 个命题变项 p₁, p₂,...pn 则该公式称为 n 元命题公式.
	在 A 中,对变项组(p₁,p₂,...pn) 指定的一组确定真值称公式的一个 真值指派 或赋值.
		若指定的一组值使A 的真值为真,则称这组值为A 的 成真指派 或 成真赋值.
		若使A 的真值为假,则称这组值为A 的 成假指派 或 成假赋值.

例1: “p取值为 T (true),q 取值为F (false) ” 是 ~p ∧ q 的一个成假指派.
	 “p取值为 F (false),q 取值为T (true) ” 是 ~p ∧ q 的一个成真指派.
	
	
	 由乘法原理很容易得到 n ( n ≥ 1) 元命题公式共有 2^n 个不同的真值指派.
	   在命题变项 p₁,p₂,p₃...pn	次序确定的情况下,(p₁,p₂,p₃..pn) 的一个真值指派可以表示一个由 0 和 1 组成的 n 位符号串.
	   例如一个含命题变项 p₁,p₂,p₃ 的命题公式 A 的一个真值指派表示 101 其含义是 p₁ 真值为 T ,p₂真值为F, p₃ 真值为 T .

*定义: 假设 A 为一个 n 元命题公式.
		若其所有 2^n 个真值指派都是 成真指派,则称 A 为 永真式 或 重言式.
		若其所有 2^n 个真值指派都是 成假指派,则称 A 为 永假式 或 矛盾式.
		若其 A 至少存在一个 成真指派 ,则称A为 可满足式.
		若 A 至少存在一个 成真指派 及 成假指派 ,则称 A 为 非重言的可满足式.

例:		p⇒ p ∨ q 是重言式.
		~p ⇔ p   是矛盾式.
		~p ∧ q   是非重言式的可满足式.
		
	重言式一定是可满足式，但反之不真。
	任意两个重言式的析取或合取仍然是矛盾式。
	任意两个矛盾式的析取或合取仍然是矛盾式。

}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

真值表{
	一个命题公式在每种真值指派（即每种命题变相取值的组合）上的值可以直观的用 真值表 来计算和表示。
		对于一个 n 元命题公式 A ，其真值表的输入端（即最左n列）的2^n 行对应于它的 2^n 个真值指派.
		输出端 (即最右一列) 对应命题公式 A 在它的 2^n 个真值指派下的真值.

*约定: 为方便构造真值表,特约定如下:
	(1) 命题变相按字典顺序排列.
	(2) 对每个真值指派,以二进制数从小到大 或 从 大到小顺序 列出.
	(3) 若公式较复杂,可先列出各子公式的真值,最后列出所求公式的真值.

例:	列出下述命题的真值表,并给出各公式的 成真指派 和 成假指派:
	(a) ( p ∨(p ∧ q)) ⇒ (~p ⇒ q)		重言式
	(b) ~(~p ∨ q) ∧ (q ∧ q)				矛盾式
	(c) (~p ∧ q) ⇒ (~q ∧ p)				非重言式的可满足式
	
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

命题的符号化{
	把一个用自然语言表述的命题表示为由命题公示的形式,称为 命题的符号化, 这是进行推理演算的首要步骤.
	命题的符号化一般经过如下三个步骤:
	1.找出各原子命题,将原子命题符号化.
	2.找出命题中各联结词,将联结词符号化.
	3.将原子命题和联结词组成一个复合命题.

例1:把下列自然语言命题符号化:
 	 说这门课讲得不好是不正确的.
		p 表示"这门课讲得好"
		则命题符号化为 ~(~p) 

例2:把下列自然语言命题符号化:
	 𝜋 和 𝘦 都是无理数.
		p 表示"𝜋 是无理数"
		q 表示"𝘦 是无理数"
		则命题符号化为 p ∧ q

例3: 把下列自然与人命题符号化:
	  俞伯牙和钟子期是好朋友.		(和 这个字很关键)
	解:		Friend(俞伯牙,钟子期)

例4: 把下列自然语言命题符号和:
	 a 属于合集 A 或者 合集 B.		(或者 很关键)
		p 表示"a属于集合A"
		q 表示"a属于集合B"
		它们是 可兼或, 命题符号化为 p ∨ q

例5: 小李生于 1978年 或者 1987年.
	  p 表示"小李生于1978年"
	  q 表示"小李生于1987年"
	    它们是 不可兼或 ,命题符号化为 p ⊕ q

例6: 只有在晴天,我才会去公园.
	  p 表示"天气晴"
	  q 表示"我去公园"
	  则命题符号化为 q ⇒ p
	   或者理解为" 如果不是晴天我就一定不去公园",这时命题符号化为 ~p ⇒ ~q 

例7: 只要是晴天,我就会去公园.
	  p 表示"天气晴"
	  q 表示"我就去公园"
	   命题符号化为 p ⇒ q

例8: 小李是一名本科生,他的专业是数学或计算机.
	  p 表示"小李是一名本科生"
	  q 表示"小李的专业是数学"
	  r 表示"小李的专业是计算机"
	 *各分句之间的关系是 合取关系.
	  命题符号化为 p ∧ (q ∨ r)

例9: 把程序语句 " IF P THEN Q ELSE R" 表达为复合命题.
	  ( P ⇒ Q) ∧ (~P ⇒ R)
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

命题逻辑的等值演算{
	设A,B 为两个命题公式,若 A⇔ B 座位一个重言式,则称A 于 B 等值, 记作 A ≡ B,称 A ≡ B 为 等值式.
	(a) "≡"并不是一个逻辑联结词,A≡B 表示A,B有等值关系,而并非命题.
	(b) 设p₁,p₂,...pn 是公式A 和公式B 中出现的全部命题变项.由定义,A,B 等值当且仅当对于命题变项p₁,p₂,...pn 的任意一组真值指派,A 和B 的取值均相同.

	判断两个命题公式是否等值主要有两个方法:
		1.真值表法
			将两个公式的真值表列出,判断输出列是否相同.
		2.等值演算法
			由一直的等值式 推演 出新的等值式.
	等值演算不能直接证明两个公式不等值.证明两个公式不等值的基本思想是找到一个真值指派使一个成真,另一个成假.

例1:
	p ∨ (p ∧ q) ≡ p				证明这两个公式等值.
	模拟真值表:		inputs
					p	q	p∧q	p∨(p∧q)　
					T	T	 T	   T
					T	F	 F	   T
					F	T	 F	   F
					F	F	 F	   F
			由此表可以得知 p 的真值 等同于等值式的结果.

*基本等值式 公式:
	交换律:		p ∨ q ≡ q ∨ p  , p ∧ q ≡ q ∧ p

*	结合律:		( p ∨ q) ∨ r ≡ p ∨ ( q ∨ r)
				( p ∧ q) ∧ r ≡ q ∧ ( q ∧ r)

*	分配律:		p ∨ ( q ∧ r) ≡ ( p ∨ q) ∧ ( p ∨ r)
				p ∧ ( q ∨ r) ≡ ( p ∧ q) ∨ ( p ∧ r)

*	幂等率:		p ∨ p ≡ p	,	p ∧ p ≡ p

*	吸收率:		p ∨ ( p ∧ q) ≡ p ,	p ∧ ( p ∨ q) ≡ p
	
*	双向否定率:	~( ~ p) ≡ p

*	德·摩根率:	~( p ∨ q) ≡ ~p ∧ ~q
				~( p ∧ q) ≡ ~p ∨ ~q

*	零率:		p ∨ T ≡ T	,	p ∧ F ≡ F

*	同一率:		p ∨ F ≡ p	,	p ∧ T ≡ p

*	排中律(非真即假):	p ∨ ~p ≡ T
	
*	矛盾律(不能即真又假):	p ∧ ~p ≡ F

*	蕴含等值式:	( p ⇒ q) ≡ ( ~p ∨ q)

*	等价等值式:	( p ⇔ q) ≡ (( p ⇒ q) ∧ ( q ⇒ p))
						 ≡ ((~p ∨ q) ∧ (~q ∨ p))

*定理(代入规则):
	假设 A 是 一个重言式,对其中所有相同的命题变项都用 同一命题公式进行代换,所得到的结果仍为 一重言式.
	重言式的值不依赖于命题变项值的变化.因此,对命题变项以任何公式替换后得到的仍是重言式.


*定理(置换规则):
	设 𝟇(A) 是含命题公式 A 的命题公式, 𝟇(B) 是用命题公式 B 置换了 𝟇(A) 中的 A 之后得到的命题公式 (不一定是每一处).
		如果 A ≡ B ,则 𝟇(A) ≡ 𝟇(B)

例1:	((p ∨ q) ∧ p) ∨ ( p ∧ r)
	  ≡	p ∨ ( p ∧ r)				使用吸收率:( p ∨ q ) ∧ p ≡ p
	  ≡ p


*对比列表			代入规则				置换规则
	使用对象:	   任意重言式			    任一命题公式
	代换对象:	  任一命题变项			    任一子公式
	被代换物:	  任一命题公式				任一与换代对象等值的命题公式
	代换方式: 代换同一命题变项的所有出现	代换子公式的某些出现
	代换结果:		仍为重言式				与原公式等值

例1:	证明 p⇒ (p⇒ r) ≡ ( p ∧ q ) ⇒ r
			≡ ~p ∨ ( ~q ∨ r)		首先去掉⇒  使用蕴含等值式 p⇒ q ≡ ~p ∨ q
			≡ (~p ∨ ~q) ∨ r			使用了交换律,将括号范围修改
			≡ ~(p ∧ q) ∨ r			德摩根率 ~( p ∧ q ) ≡ ~p ∨ ~q
			≡ (p ∧ q) ⇒ r		蕴含等值式 括号内符号不变,看成一个整体.

例2:	证明(~p ∧ (~q ∧ r)) ∨ (q ∧ r) ∨ (p ∧ r) ≡ r
		  ≡ (~p ∧ (~q ∧ r)) ∨ ((q ∨ p) ∧ r)		使用分配律
		  ≡ ((~p ∧ ~q) ∧ r) ∨ ((q ∨ p) ∧ r)		使用结合律
		  ≡ ( ~(p ∨ q) ∧ r) ∨ ((q ∨ p) ∧ r)		使用德摩根率
		  ≡ ( ~(p ∨ q) ∨ (q ∨ p)) ∧ r			使用分配律
		  ≡ T ∧ r		使用排中律 将括号内的值变为了 T 
		  ≡ r

例3:	证明 ((p ∨ q) ∧ ~(~p ∧(~q ∨ ~r))) ∨ (~p ∧ ~q) ∨ (~p ∧ ~r) 是重言式.
		   ≡ ((p ∨ q) ∧ (p ∨ (q ∧ r))) ∨ ~(p ∨ q) ∨ ~(p ∨ r),德摩根率 否定率
		   ≡ ((p ∨ q) ∧ ((p ∨ q) ∧ (p ∨ r))) ∨ ~(p ∨ q) ∨ ~(p ∨ r)  分配律
		   ≡ ((p ∨ q) ∧ (p ∨ r)) ∨ ~(p ∨ q) ∨ ~(p ∨ r)	 结合律 逆等率
		   ≡ ((p ∨ q) ∧ (p ∨ r)) ∨ ~((p ∨ q) ∧ (p ∨ r))		德摩根率
		   ≡ T			通过排中律得到 T

例4:	简化语句:“情况并非如此: 如果他不来,那么我也不去” .
		 p 表示 “他来”		q 表示 “我去”
			~(~p ⇒ ~q)  化简为 ~p ∧ q
						简化之后就表示 “我去了,而他没来”

例5:	简化语句:“不得不说如果不是因为他是不得已而为之而且没有造成恶劣后果的话我是不会原谅他的”
	解:	首先找出原子命题:
		p:	他这么做		q: 他造成了恶劣后果		r: 我原谅他
		~ ~(~(~ ~p ∧ ~q)⇒ ~r) ≡ r ⇒ p ∧ ~q
		相当于: “ 我原谅他,是因为他这么做了而且没有造成恶劣后果”,逻辑语言
		

例6:	程序简化 if A ∧ B then
					if B ∨ C then
						X
					Else
						Y
					End
				 Else 
					if A ∧ C then
						Y
					Else
						X
					End
				 End

		解:
			((A ∧ B) ∧ (B ∨ C) ⇒ X) ∧
			((A ∧ B) ∧ ~(B ∨ C) ⇒ Y) ∧
			(~(A ∧ B) ∧ (A ∧ C) ⇒ Y) ∧
			(~(A ∧ B) ∧ ~(A ∧ C) ⇒ X)

			简化后 if A ∧ ~B ∧ C
					then
					  Y
					Else
					  X
					End

例7:	小张或小李是三八红旗手; 如果小张是三八红旗手,会告知大家的; 如果小李是三八红旗手,那么小赵也是; 大家并没有被告知小张是三八红旗手.请问:谁是三八红旗手?
	解:	p: 小张是三八红旗手
		q: 小李是三八红旗手
		r: 大家被告知小张是三八红旗手
		s: 小赵是三八红旗手
	(p ∨ q) ∧ (p ⇒ r) ∧ (q ⇒ s) ∧ ~r  
		简化后 ≡ ~p ∧ q ∧ s ∧ ~r
	小李是三八红旗手





}


