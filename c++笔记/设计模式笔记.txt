Gof 提出的设计模式有23个,包括:
    创建型(Creational)模式 : 如何创建对象;    简单工厂模式, 工厂方法模式, 抽象工厂模式, 单例模式.
    结构型(Structural)模式 : 如何实现类和对象的组合;     代理模式, 装饰模式, 外观模式, 适配器模式.
    行为型(Behavioral)模式 : 类或对象怎样交互以及怎样分配职责.      模版方式模式, 命令模式, 策略模式, 观察者模式.

  有一个 "简单工厂模式" 它不属于 GOf 23 种设计模式, 但大部分的设计模式书籍都会对它进行专门的介绍.

设计模式目前种类:  Gof 的 23种 + "简答工厂模式" = 24 种.


------------------------------------------------------------------------------------------------------------
// 一切的内容都有范式代码,去文件中找
------------------------------------------------------------------------------------------------------------
!很重要.  设计模式的基础是 多态.

    单一指责原则: 类的指责单一,对外只提供一种功能,而引起类变化的原因都应该只有一个.
!  开闭原则 : 类的改动是通过增加代码进行的,而不是修改源代码. 做到对扩展开放,对修改关闭.
    里氏代换原则: 任何抽象类出现的地方都可以用它的实现类进行替换,实际就是虚拟机制,语言级别实现面向对象功能.
!  依赖倒转原则: 依赖于抽象(接口),不要依赖具体的实现(类),也就是针对接口编程.!
    接口隔离原则: 不应该强迫用户的程序依赖他们不需要的接口方法.一个接口应该只提供一个对外功能,不要把所有操作都封装在一起.
    合成复用原则: 如果使用继承,会导致父类的任何变换都可能影响到子类的行为.如果使用对象组合,就降低了这种依赖关系.优先用组合.
!  迪米特法则: 一个对象应当对其他对象尽可能少的了解,从而降低各个对象之间的耦合,提高系统的可维护性.例如在一个程序中,各个模块
            之间相互调用时,通常会提供一个统一的接口来实现.这样其他模块不需要了解另一个模块的内部实现细节,这样当一个模块内
            部的实现发生改变时,不会影响其他模块的使用. (黑盒原理).


------------------------------------------------------------------------------------------------------------

 法则表现在程序种形式:

   开闭原则  对外扩展开放, 对修改关闭, 增加功能是通过增加代码而实现的,而不是去修改源代码. 
   迪米特法则 又叫最少知识原则. 知道的越少,而且还能把事情完成 就行.
   复用原则  选择继承和组合的时候,优先使用组合 .

------------------------------------------------------------------------------------------------------------


   简单工厂模式 :
        工厂是个类,里面包含了创建其他类的方法,其中有个对象生成器.  使用的时候应该传入一个参数,让工厂知道应该创建什么对象.
        优点: 1 客户端和具体实现类解耦合.
             2 对于某些对象创建过程比较复杂的情况,我们就不用考虑了.
                  
        缺点: 1 简单工程模式,增加新的功能是通过修改源代码实现的, 不符合开闭原则.
             2 这个类的职责过重.一旦这个类发生问题,会影响很多使用这个工厂的模块.
             
        使用场景: 
             1 工厂类负责创建的对象比较少, 由于创建的对象较少不会造成工厂方法中的业务逻辑太过复杂.
             2 客户端只需要知道传入工厂类的参数,对于如何创建对象并不关系.
             
             

   工厂方法模式 = 简单工厂模式 + "开闭原则" 
        就是把工厂也变成抽象类, 每增加一个对象,就增加一个具体的工厂类.  (很不好,成倍数增长的类).
        
        使用场景: 
            1 客户端不知道他所需要的对象的类.
            2 抽象工厂类通过其子类来创建哪个对象.
    
    
   抽象工厂模式: 针对产品族, 而不是产品等级.
        产品族: 同一产地或者同一厂商,功能不同.
        产品等级: 功能相同,产地或者工厂不同.
    


------------------------------------------------------------------------------------------------------------

!!! 重要  模式

    单例模式: 控制某个类型的对象个数,单例模式中,系统只有一个对象.
 !     实现单例步骤:    单例在程序中只会存在一份 , 所以不考虑内存泄露问题,也不需要提供析构函数.
         1.构造函数私有化.
         2.增加静态私有的当前类的指针变量.
         3.提供一个静态对外接口,可以让用户获得单例对象.

    单例模式也分为 懒汉式和 饿汉式.  (饿汉式更加安全)
      他们的区别是, 饿汉式的类对象在main之前就构建,懒汉式的类是在需要的时候构建.
 !  但是懒汉式碰到多线程 会可能不安全,有可能会创建两个对象,这样就不是单例了.
 !  饿汉式碰到多线程也会保持单例模式,所以不需要担心会不安全.



------------------------------------------------------------------------------------------------------------


    代理模式: 为其他对象提供一种代理 以控制对这个对象的访问.  (参考代理服务器)
        不让用户直接申请到对象,而且间接来提供,有的时候也可以进行验证.

------------------------------------------------------------------------------------------------------------

    
    外观模式(Facade): 就是将复杂的子系统抽象到同一个的接口进行管理,外界只需要通过此接口与子系统进行交互
                   ,而不必要直接与复杂的子类系统进行交互. 为一组具有类似功能的类群,提供一个一致的简单的界面.
    
    (Facade)外观角色: 为调用方,定义简单的调用接口
    (SubSystem)子系统角色: 功能提供者. 指定提供功能的类群(模块或子系统).




------------------------------------------------------------------------------------------------------------


    适配器模式 就是将已经写好的接口, 但是这个接口不符合需求, 将写好的接口转换成目标接口.
      主要用到的是抽象类, 一个返回子类的函数, 一个子类伪函数. 一个需要转换的接口.


 
------------------------------------------------------------------------------------------------------------

    模版方法模式: 定一个操作中算法的框架,而将一些步骤延迟到子类中.

       模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤.

    模版方法模式的优缺点
       优点: 1.在父类中形式化的定义一个算法,而又它的子类来实现细节的处理,在子类实现详细的处理算法时 并不会改变算法中步骤
                 的执行次序.
             2.模版方法模式是一种代码复用技术,它在类库设计中尤为重要,它提取了类库中的公共行为,将公共行为放在了父类中,而
                  通过其子类来实现不同的行为,它鼓励我们恰当使用继承来实现代码复用.
             3.可实现一种反向控制结构,通过子类覆盖父类的钩子方法来决定某一步骤是否需要执行.
             4.在模版方法模式中可以通过子类来覆盖父类的基本方法,不同的子类可以提供基本方法的不同实现,更换和增加新的子类
                  很方便,符合单一职责原则和开闭原则.  


------------------------------------------------------------------------------------------------------------

    策略模式 定义了一系列的算法,并将每个算法封装起来, 而且使他们还可以相互替换. 
    策略模式让算法独立于使用它的客户而独立变化.

    Context(环境类) : 是使用算法的角色,它在解决某个问题(即实现某个方法)时可以采用多种策略.用于定义所采用的策略.
    Stategy(抽象策略类): 它为所支持的算法声明了抽象方法,是所有策略类的父类,它可以是抽象类或具体类,也可以是接口.
    ConcreteStrategy(具体策略类): 它实现了在抽象策略类中声明的算法,在运行时,具体策略类将会覆盖在环境类中定义的抽象策略
                                  对象,使用一种具体的算法实现某个业务处理.



------------------------------------------------------------------------------------------------------------

    命令模式 :对象指针和多态的运用.  (一定要看范例.).

    
------------------------------------------------------------------------------------------------------------

    观察者模式:  一个类的变化可以引起其他的很多类发生变化. 发生改变的对象被称为观察目标,而被通知的对象称为观察者.

------------------------------------------------------------------------------------------------------------

    装饰模式 : 又称包装模式, 通过一种对客户端透明的方式来扩展对象功能, 是继承关系的一种替代.
    装修模式 可以动态给一个类增加功能.

------------------------------------------------------------------------------------------------------------
