零散笔记:善用查找gcc -m64 file.h      // 编译后是64位程序#define _CRT_SECURE_NO_WARNINGS         // win vs接口的封装和设计(功能的抽象和封装)  接口api的使用能力 (要会用别的人写的接口)  接口api的查找能力 (要找到手册,linux用man,头文件,函数名字.功能,参数,返回值)  接口api的实现能力 (要会写)建立正确程序运行内存分布图   内存四区模型  (很重要)   函数调用模型  (比如递归)CS:客户端服务器   (安全不灵活)BS:浏览器和服务器 (灵活但不安全)术语: 打桩  (就是先写函数之类的声明放在那里,函数体并不实现,能够编译通过)#if 0  #endif    //这两个很好用  可以用来阶段测试代码.中间的代码是不会预处理和编译的system("");    // pause 暂停;   cls 清屏;   sscanf(); 和 sprintf(); 在程序中使用的特别多,因为有正则表达式,所以需要的时候去查找就好了.内存出错误一般有两种情况:    1:     2:     内存泄漏解决方案:(每个平台有会有检测工具)    vs方案:还是要写代码,检测内存,然后打开 项目->属性->c/c++ ->预处理器-> 添加预处理器定义   **就算在检测也不如写代码的时候多多注意,多多留意.写好代码.    <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<程序中很容易出现buf,但是经常把各个细节运行状况存入到日志文件中就很容易来排查错误了.(最好写个接口)    #define FILENAME "./debug.log"     //这个宏定义代表在当前目录的一个文件 debug.log 日志错误日志的一些格式和包含的内容:        文件名__FILE__,文件行号__LINE__,        以及 错误级别:  0 -- 没有日志       // 没问题;                         1 -- dubug 级别     // 级别最低，可以随意的使用于任何觉得有利于在调试时更详细                                             //     的了解系统运行状态的东西;                         2 -- info级别       // 重要，输出信息：用来反馈系统的当前状态给最终用户的；                         3 -- warning 级别   // 警告, 可修复，系统可继续运行下去；                         4 -- err 级别       // 错误,可修复性，但无法确定系统会正常的工作下去;                         5 -- fatal级别      // 严重错误, 相当严重，可以肯定这种错误已经无法修复，                                             //     并且如果系统继续运行下去的话后果严重。                         实际例子:// log.h  #ifndef _ITCAST_LOG_H_#define _ITCAST_LOG_H_ /*#define IC_NO_LOG_LEVEL			0#define IC_DEBUG_LEVEL			1#define IC_INFO_LEVEL			2#define IC_WARNING_LEVEL		3#define IC_ERROR_LEVEL			4#define IC_FATAL_LEVEL			5---------------------------------                          const char *file：文件名称int line：文件行号int level：错误级别0 -- 没有日志1 -- debug级别2 -- info级别3 -- warning级别4 -- err级别5 -- fatal级别int status：错误码const char *fmt：可变参数*//************************************************************************///实际使用的Levelextern int  LogLevel[5];void ITCAST_LOG(const char *file, int line, int level, int status, const char *fmt, ...);--------------------- //log.c 的实现 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>// 我修改过,也可能不完美,需要再次修改!!!#define _CRT_SECURE_NO_WARNINGS#include <sys/types.h>#include <sys/stat.h>#include <fcntl.h>#include <stdarg.h>#include <string.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#include "ItcastLog.h" #define ITCAST_DEBUG_FILE_	"socketclient.log"#define ITCAST_MAX_STRING_LEN 		10240 //Level类别#define IC_NO_LOG_LEVEL			0#define IC_DEBUG_LEVEL			1#define IC_INFO_LEVEL			2#define IC_WARNING_LEVEL		3#define IC_ERROR_LEVEL			4#define IC_FATAL_LEVEL			5 int  LogLevel[6] = { IC_NO_LOG_LEVEL, IC_DEBUG_LEVEL, IC_INFO_LEVEL, IC_WARNING_LEVEL, IC_ERROR_LEVEL,                        IC_FATAL_LEVEL }; //Level的名称char ICLevelName[6][10] = { "NOLOG", "DEBUG", "INFO", "WARNING", "ERROR" ,"FATAL"}; static int ITCAST_Error_GetCurTime(char* strTime){	struct tm*		tmTime = NULL;	size_t			timeLen = 0;	time_t			tTime = 0; 	tTime = time(NULL);	tmTime = localtime(&tTime);	//timeLen = strftime(strTime, 33, "%Y(Y)%m(M)%d(D)%H(H)%M(M)%S(S)", tmTime);	timeLen = strftime(strTime, 33, "%Y.%m.%d %H:%M:%S", tmTime); 	return timeLen;} static int ITCAST_Error_OpenFile(int* pf){	char	fileName[1024]; 	memset(fileName, 0, sizeof(fileName));#ifdef WIN32	sprintf(fileName, "c:\\debuglog\\%s", ITCAST_DEBUG_FILE_);//log文件路径#else	sprintf(fileName, "%s/log/%s", getenv("HOME"), ITCAST_DEBUG_FILE_);#endif 	*pf = open(fileName, O_WRONLY | O_CREAT | O_APPEND, 0666);	if (*pf < 0)	{		return -1;	} 	return 0;} static void ITCAST_Error_Core(const char *file, int line, int level, int status, const char *fmt, va_list args){	char str[ITCAST_MAX_STRING_LEN];	int	 strLen = 0;	char tmpStr[64];	int	 tmpStrLen = 0;	int  pf = 0; 	//初始化	memset(str, 0, ITCAST_MAX_STRING_LEN);	memset(tmpStr, 0, 64); 	//加入LOG时间	tmpStrLen = ITCAST_Error_GetCurTime(tmpStr);	tmpStrLen = sprintf(str, "[%s] ", tmpStr);	strLen = tmpStrLen; 	//加入LOG等级	tmpStrLen = sprintf(str + strLen, "[%s] ", ICLevelName[level]);	strLen += tmpStrLen; 	//加入LOG状态	if (status != 0)	{		tmpStrLen = sprintf(str + strLen, "[ERRNO is %d] ", status);	}	else	{		tmpStrLen = sprintf(str + strLen, "[SUCCESS] ");	}	strLen += tmpStrLen; 	//加入LOG信息	tmpStrLen = vsprintf(str + strLen, fmt, args);	strLen += tmpStrLen; 	//加入LOG发生文件	tmpStrLen = sprintf(str + strLen, " [%s]", file);	strLen += tmpStrLen; 	//加入LOG发生行数	tmpStrLen = sprintf(str + strLen, " [%d]\n", line);	strLen += tmpStrLen; 	//打开LOG文件	if (ITCAST_Error_OpenFile(&pf))	{		return;	} 	//写入LOG文件	write(pf, str, strLen);	//IC_Log_Error_WriteFile(str); 	//关闭文件	close(pf); 	return;}  void ITCAST_LOG(const char *file, int line, int level, int status, const char *fmt, ...){	va_list args; 	//判断是否需要写LOG	//	if(level!=IC_DEBUG_LEVEL && level!=IC_INFO_LEVEL && level!=IC_WARNING_LEVEL && level!=IC_ERROR_LEVEL)	if (level == IC_NO_LOG_LEVEL)	{		return;	} 	//调用核心的写LOG函数	va_start(args, fmt);	ITCAST_Error_Core(file, line, level, status, fmt, args);	va_end(args); 	return;} void main(){	int rv = -3;	ITCAST_LOG(__FILE__, __LINE__, LogLevel[4], rv, "func cltSocketRev2: (buflen == NULL) [%d]", rv);	system("pause");}//结束<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<日志格式:总结起来， 错误日志格式可以为：log.error(“[接口名或操作名] [Some Error Msg] happens. [params] [Probably Because]. [Probably need to do].”);log.error(String.format(“[接口名或操作名] [Some Error Msg] happens. [%s]. [Probably Because]. [Probably need to do].”, params));     经常用来调试BUG的宏定义:__FILE__   // 输出文件位置 %s__LINE__   // 输出调用这个宏 的行数        ****************************************************************************正常开发.h 中的代码格式(重要)(强调了兼容性)(这段代码可以使用C++编译器来执行)  #pragma once   //防止头文件重复包含(也可以替换 #ifndef xx #define xx)   #ifdef __cplusplus   //告诉编译器这段代码用C语言编译而不是C++的,(可以用c++的编译器)          // 是cpp中自定义的一个宏,而不是我们自己写的,最主要是兼容C++,可以使用g++命令          // 如果是 C++ 编译器,按C标准编译,(两个下横线) .如果定义了则向下进行           extern "C"   //而这一部分就是告诉编译器，如果定义了__cplusplus(即如果是cpp文件，          //   extern "C"{ //因为cpp文件默认定义了该宏),则采用C语言方式进行编译.  {     // 记住这个大括号位置  #endif      // 结束上一个 __cplusplus  的声明  ,但是上面有个括号 ,与最近的做匹配   //  这里写真正要写的东西 , 函数声明,变量声明之类的,是C类型的  .......  #ifdef __cplusplus    // 这段代码 只是为了声明下面的括号  }     // 这是对应上面那个大括号  #endif   //这个只是照顾这个 大括号 ****************************************************************************如何看懂带算法的程序  1, 流程  2, 每个语句功能  3, 试数  4, 调试  5, 模仿 改  6, 不看代码写如果数组作为函数形参,数组形参退化为指针.(面试经常考)   例如 void arra( int arr[10]);   //等价于下面两项,其中的10这个参数不生效         void arra(int arr[]);  或者 void arra(int* arr)内存四区：  1,数据类型的本质: 是固定内存大小的别名.     数据类型的作用: 编译器预算对象(变量)分配的内存空间大小. 注: 数据类型只是模具，编译器并没有分配空间,只有根据具体类型(模具)创建变量(实物)，编译器才会分配内存空间.       void 类型只有指针没有普通类型,因为指针在32位是占4字节,64位则占8个字节不变,所以只有void的指针.       void 的类型不能够直接确定,所以定义普通定义的时候将会无法知道他需要多少内存,也就无法继续编译.	   void 类型指针可以被赋值,但是必须要强制类型转换,无论使用还是赋值.函数 也是一种数据类型,它可以自定义类型,有函数指针,也是入口地址.  2,变量的概念: 既能读又能写的 内存对象. 若一但初始化后不能修改的对象则成为常量.    变量的本质: 一段连续内存空间的别名. 变量就相当于门牌号,内存相当于房间,互为查找.                数据类型当做模具,变量是根据模具创建出来的实物.----------------------------------------------------------------------------------------------  3, 程序内存四区模型:      硬盘          内存                    执行过程中,c程序内存管理      程序  -->  代码 <- 操作系统代码  ->  堆区(heap):malloc/new/free/delete                                               程序运行时程序员管理,程序结束后操作系统管理                                           栈区(stack): 程序局部变量.函数里面写的都是变量.                                               大部分都是操作系统管理.                                           全局区(静态区)(glohal):常量和全局变量,静态变量,                                              文字常量区, 初始化的,未初始化的,操作系统管理                                           程序代码区(code): 操作系统托管,我们不关心.---------------------------------------------------------------------------------------------堆区(heap):一般由程序员分配释放(动态内存申请和释放),若程序员不释放,程序结束后'可能'由系统回收.栈区(stack):由编译器自动分配释放,存放函数的参数值,局部变量的值等.全局区(静态区)(glohal):全局变量和静态变量的存储是放在一块的,初始化的全局变量和静态变量在一块      区域,未初始化的全局变量和未初始化的静态变量在相邻的另一块区域,文字常量区也放在这里      该区域在程序结束后由操作系统释放.程序代码区(code): 存放函数体的二进制代码,操作系统托管,我们不关心.例: #include <stdio.h> char* get_str()    //返回一个char类型(需要注意) {     char *p = "asd";   //文字常量区,全局区     return p; } int main(void){  char * p =NULL;   // 栈区  int a = 10;   // 栈区     p = get_str();  printf(" p = %s, p = %d",p,p );   // %s :指针指向内存区的内容   // %d :打印p 本身的值  return 0;}---------------------------------------------------------------------------------------------栈的生长方向:(高地址->低地址),内存生长方向(低地址->高地址)在栈中变量的地址是从高到低的,而数组则是使用内存顺序 从低到高. 例如: int a; int b; printf("a= %p,b= %p",&a,&b);  // a的地址比b大.递减       char c[10]; printf("c = %d, c+1 = %d",c,c+1);  // c+1比c大.递增堆的生长方向:(低地址->高地址) 也就是内存方向	    4,内存操作流程:    (1) 操作系统把物理硬盘代码 load 到内存.    (2) 操作系统把 c 代码分成四个区.---------------------------------------------------------------------------------------------指针强化:()    [] 优先级比 * 高!!!!!!!!    指针也是一种数据类型,指针变量也是一种变量,可以储存其他类型数值的地址.	指针指向谁,就把谁的地址赋值给指针.	*钥匙,通过*可以找到指针指向的内存区域,操作的还是内存.	*放在=左边,给内存赋值,写内存. int a = 0;  int *p = a;	*放在=右边,取内存的值,读内存. int b = *p;    指针变量,和指向 指向的内存是两个不同的概念.    指针自己也有地址和内存,它储存的是指向的对象的地址(%d 指向的地址(十进制)).    指针 p = p + 1 ; 会得到所指元素类型的下一个元素(int 就是+4,char +1).    当函数中有数组参数,都会退化成指针,所以不会知道数组有多大,只能知道这个指针有多大(4字节).  间接赋值是指针存在的最大意义:    间接赋值三大条件:  1) 两个变量.  2)建立关系.  3) 通过* 操作符进行间接赋值.    二级指针和指针数组和多级指针强化:()    如果一个指针变量存放的又是另一个指针变量的地址,则成这个指针变量为指向指针的指针变量.也称二级指针.    函数形参应该使用二级指针,传入的参数应该使用一级指针,这样就可以用被调函数来进行内存操作了.        指针数组. char *p[3]={"11","22",p2};  //存储指针,也存储指向字符串指针,都是地址(4字节),使用时p[2];    二级指针数组 char **p1[3] = {p6,p2,p3}; // 里面都是二级指针.                 char **p = (char**)malloc(n*sizeof(char*)); //分配内存,n个指针(4字节),仅仅只是指针.    多级指针数组 char ***p7[3] = {p4,p5;};    指向指针数组的指针 char *(*p8)[3] = &p;    数组指针 char (*pp)[5] ;   //指向 char [5] 数组的指针.             char *(*pa)[6];   //指向 char *[6] 指针数组的指针.             int a[5];  int *A[5] = &a;  //指向整个数组,而不是首元素地址.             A++ ; //会跳 5*4 = 20个 字节.而不是单纯跳指针.指向的类型不同,导致步长不一样.                          typedef int A[10]; A *b;  // b 是指向一个int [10] 数组的一个指针.             typedef char (*a)[3]; a pp;  // pp是指向 char [3] 数组的一个指针.             !!声明中一旦()内只有一个*则这是一个指针,如果出现(*p[5]) 则这是一个数组,里面存放着5个指针.                              二级指针的数组和指向对象使用排序法时,应该使用strcpy()来互换内存块数据,而不是互换指针.!!!       有typedef 就是类型,没有就是变量.    二维数组中心思想: int a[i][q];   *(*(a+i)+j) 等价于 &a[i][q] 等价于 a[i][j];        数组首元素和数组元素地址不同,步长不同,a[0] =数组元素地址4, &a = 首元素地址        二维数组本质就是一位数组,是线性存储的,可以使用一个总元素个数的循环搞定输出.        a ;   //代表第0行首地址,也就是整个数组的地址.        a+i -> &a[i] ; //代表第i 行首地址.        *(a+i) -> a[i] ; //代表第0行首元素地址.        *(a+i)+q  -> &a[i][q] ;  //第 i行 第q 列元素的地址.        *(*(a+i)+q)  -> a[i][q] ;  // 第i 行 第q列 元素的值.      例: int a[3][4];  int (*P)[4] = a;  *(*(P+i)+w) = a[i][w];        !!!! 一维数组 int a[10];           a ;   //表示数组首行首元素地址, 是 一级指针.       &a;   //表示数组的首元素地址, 是 二级指针.       a+1;  //表示 跳过1元素,一元素 为4字节, 步长为4字节.       &a+1; //表示 跳过整个数组, 整个数组长度 10*4 =40 , 步长为 40.      sizeof(a) ;  //传参为: 数组首行首元素的地址,测数组 (int a[10]) 的长度, 10*4= 40;      sizeof(a[0]); //传参为: 数组首元素(不是地址), 每个元素为 int 类, 4字节;      sizeof(&a);   //传参为: 一维数组整个数组的地址(首行地址),编译器当做指针类型,4字节;!!(重要) 首行地址  转换为 行首元素地址(加*);     &a; //首行地址     *&a;//首行首元素地址          !!(重要) 如果想在函数内改变主函数变量的值 应该这么写:    int main(void){  long  n = 0 ; swap (&n);}         void swap(long *n){ *n = 0;}    这样就可以来间接修改主函数内的值.       ----------------------------------------------------------------------------------------------------------------指针做函数参数的输入输出特性:     输入: 主调函数分配内存.    输出: 被调用函数分配内存.    被调用函数是在 堆区(heap) 上分配内存,而不是 栈区(stack)上.否则会被销毁的可能.    例:int main() { char * std = NULL; macpy(&std);}       macpy(char **std){ char * sdr =malloc(100); strcpy(sdr,"aa"); *std = sdr;free(sdr);sdr=NULL;}        // 这样就可以用被调函数来进行内存操作了,得需要二级指针.    函数内 int ** p; int * k;   *p = k;   //这样可以间接赋值,一级和二级指针的赋值.       strlen(数组); 测字符串长度,不包括数字0,字符\0.是数组中元素的个数的真正长度;(数组一般都用这个)sizeof(数组); 测数组长度, 包含数字0,字符\0. 是数组定义时的长度,而不是元素个数,所以比stlen()多;	   char str[100]="abcd";    sizeof(str); //返回100     stdlen(str); //返回4	   char str2[] ="abcdef";   sizeof(str2); //返回7      stdlen(str); //返回6		char* strstr(cosnt char *str1,const char * str2); //从str1中查找与str2相同的字符串然后返回地址,否则NULL.int isspace(char c); //检查c是否为空格和\n,\t,\r,\v,\f .找到返回true 否则false.,这是宏不是函数,<ctype.h>int strcmp(char *str1,char* str2); 比较两个字符串,1比2大就返回正数,相等是0.int strcpy(char *str1,char* str2);  将2的字符串拷贝给1,不会添加 '\0' .char* strstr(char *str1,char* str2); 从1中查找2,找到返回指指向那里的指针,没找到NULL.sizeof(char *)   = 4  ;   //无论多少*   都是等于4 ;char ** name = (char**) malloc(sizeof(char*) *3 );    // 给二级指针申请内存,使用时还需要向下继续        name[0] = (char*)malloc(30); //继续申请30个字节内存空间,由name[0]元素指向.然后就可以存入数据了.        strcpy(name[0],"lllasd");  // 将字符串存入, 然后打印时当数组 printf("%s",name[0]); 就可以了.char*  可以指向数组的.---------------------------------------------------------------------------------------------------------const 提高:    const 与指针作用域规则:从左往右看,跳过类型关键字,看修饰哪个字符,(类型不重要直接忽略).       1) 如果是*,说明指针指向的内存不能改变. char const * p; //char 中的内容不能变.       2）如果是指针变量,说明指针的指向不能改变,指针的值不能修改.  char * const p;//指针不能指向别的地方       sprintf(输出对象,"字符串",和printf一样);例如: struct a{int age;}; sprintf(a.age,"bas%d",a.age);----------------------------------------------------------------------------------------------------------struct 结构提高:    typedef struct { int ega; char * name} T;  //声明一个结构体类型T    T * p1 = (T*)malloc(3* sizeof(T));     // p1是个指针,指向T结构,可以看成一个数组 T p1[3];    p1.mame = (char*)malloc( 30 );  // 结构中的char * 也得分配堆空间才行,每个name 都要分配,循环    free(p1[i].name);  p1[i].name = NULL;  // 一个一个释放char* 的堆空间.    free(p1);  p1 = NULL;    //  !!!(重点) 因为p1 是一级指针,释放一次就可以了.看成清空数组.        在有二级指针的函数形参情况下, p1[i]->ega;二级指针   p[i].ega;一级指针. p.ega 变量,不是指针.    T ** temp;  T* p2;  *temp = p2;    //可以这样写在函数里间接赋值结构体内的二级指针成员变量:    typedef struct {char ** stu} S;   //这个结构体变量中有个二级指针.    S * p;  p = (S*)malloc(sizeof(S)); //首先为p分配内存,因为他也是指针    p->stu = (char**)malloc(3* sizeof(char*);  //为stu二级指针分配内存,指向三个char* 变量.(4字节)    p->stu[0] = (char*)malloc(30);  //分配堆空间,他是stu二级指针中的一个. 分配空间结束.    strcpy(p->stu[i], "lily");  //这样来向堆空间中拷贝内容.    printf("%s  \n", p->stu[i]);  // 可以这样打印使用.    free(p->stu[i]);  //要采用循环释放    free(p);    //完全结束.结构体数组指针而且带二级指针成员变量:    typedef struct {char ** stu} Q;   //这个结构体变量中有个二级指针.    Q * w;  w = (q*)malloc(sizeof(Q) * 3 ); //首先为p分配内存,因为他也是指针,而且是个数组.等价 Q w[3];    for(int i=0;i<3;i++){         //需要循环来为stu来申请堆空间        w[i].stu = (char**)malloc(3* sizeof(char*));   //  *(w+i)->stu 与前面等价,申请stu 中3个指针的空间.        for(int j =0; j < 3; j++) {            (w+i)->stu[j] = (char *)malloc(30);  //分配堆空间,用来存数据. 与 w[i].stu[j] 等价            char buf[30]; sprintf(buf,"%d data",i);  //准备数据,用来存入str[i] 中.(下属元素指针).            strcpy( w[i].stu[j] ,buf);  // 写入数据. 与 (w+i)->stu[j] 等价            }        }    for (i = 0; i < 3; i++)    //main 内的输出打印数据    {        printf("%s ,%s  ,%s \n", w[i].stu[0], (w+i)->stu[1], q[i].stu[2]);    }        for (i = 0; i < 3; i++)     // main 内的 释放内存模块    {        for (j = 0; j < 3; j++)        {            if (w[i].stu[j] != NULL)            {                free(w[i].stu[j]);                w[i].stu[j] = NULL;            }        }        if (w[i].stu != NULL)        {            free(w[i].stu);            w[i].stu = NULL;        }    }    if (w != NULL)    {        free(q);        w = NULL;    }    int createTeacher(Teacher** tmp, int n1,int n2)   // 申请内存函数模块{    if (tmp == NULL)    {        return -1;    }    Teacher *q;    q = (Teacher*)malloc(sizeof(Teacher) * n1);        int i = 0;    int n = 0;    int j = 0;    for (i = 0; i < n1; i++)    {        q[i].stu = (char**)malloc(n2 * sizeof(char *));        for (j = 0; j < n2; j++)        {            (q + i)->stu[j] = (char*)malloc(30);            char buf[30];            sprintf(buf, "name %d %d %d %d", i, i, j, j);            strcpy((q + i)->stu[j], buf);        }    }    *tmp = q;    return 0;}        void showTeacher(Teacher* q, int n1, int n2)   // 打印输出字符串函数模块{        if (q == NULL)    {        return ;    }    int i = 0;    int j = 0;    for (i = 0; i < n1; i++)    {        for(j = 0; j<n2;j++)            printf("%s , ", q[i].stu[j]);                printf("\n");    }    printf("\n");    return 0;}        void showTeacher(Teacher* q, int n1, int n2)  //释放内存函数模块{    if (q == NULL)    {        return ;    }    int i = 0;    int j = 0;    for (i = 0; i < n1; i++)    {        for(j = 0; j<n2;j++)            printf("%s , ", q[i].stu[j]);                printf("\n");    }    printf("\n");}            int main(void)     // int main 主函数原型  {    Teacher *q = NULL;    int ret = 0;    ret = createTeacher(&q, 3,3);    if (ret != 0)    {        return ret;    }    showTeacher(q, 3, 3);     //多多注意指针 是引用还是直接传递    freeTeacher(&q, 3, 3);	printf("\n");	system("pause");	return 0;}    typedef struct {   char **stu ;} Teacher;     // 结构体    注意结构体中指针的深拷贝的浅拷贝,嵌套指针需要每个独立申请内存,才算的上是深拷贝.            结构体字节对齐:按照结构体内占用内存最大的类型的倍数来填补字节,使之对齐.顺序很重要.    例:  typedef struct { short age; long long id; } T;  // 32位中 short 占2字节 longlong 占8字节            T t1[3];              int n1 = (int)&t1[0].age;   //得到第一个的地址   来计算偏移量            int n2 = (int)&t1[1].age;   //得到第二个的地址   来计算偏移量         // n2 -n1 = 16  // 将short自动补全为 8字节,但是实际使用还是2字节,后面都是补全的0,不能使用.         // 有的时候会补全为自身的倍数,而不是奇数来存储.                  c c c c c c c c     double  8个         a a a a d d * *     int + short   补全规则 会把short 放到int 后面 进行补全                   a a a a * * * *     int         c c c c c c c c     double         d d * * * * * *     short   类型顺序不同会导致补全不同-------------------------------------------------------------------------------------------------------------!!!  文件操作有缓冲区 只是针对 ANSI C  (标准C),的一个库函数.   EOF 文件结束(end of file)    有关概念:    根据文件的逻辑结构:            记录文件: 具有一定结构的记录组成(定长和不定长).            流式文件: 由一个个字符(字节)数据顺序组成. (我们操作的一般是这个文件)    根据储存介质:            普通文件: 储存介质文件.(磁盘,磁带). <放在硬盘上的文件>(嵌入式linux一切皆文件,没有设备文件)            设备文件: 非存储介质(键盘,显示器,打印机).  <标准输入,标准输出 之类的>    按数据的组织形式:            文本文件: ASCII 文件,每个字节存放一个字符的 ASCII 码.(utf8)            二进制文件: 数据按其在内存中的存储形式原样存放.  文件缓冲区: 每个系统的缓冲区都不一样,主要是提高效率,当写入数据的时候会临时放在缓冲区,如果有fflush()函              数调用或者缓冲区已满和程序结束的时候才会把数据写入目标文件.(linux mac win 都是不一样的),              (考试会问,但是实际使用并不关心). 文件缓冲区只是针对普通文件,并不会针对设备文件(比如 stdout 直接输出到屏幕走的是设备文件),无权管理.  ---------------------------------------------------------------------------------------------------------------- 文件 操作API接口函数:  (文件读写函数)   EncFile 加密文件     DecFile 解密文件 (需要判断返回值是否为空)*字符 读写 int fgetc(FILE*);    // 按 字符 读文件函数, 返回从文件内读取到的字符 int fputc(int c,FILE*);  // 写文件, 把c字符写入文件, 返回值 0写入成功,非0写入失败 int feof(FILE*) ;   // 按 字符 读取文件寻找EOF,找到时返回 1 ,<经常用来做循环读文件 > (需要判断返回值是否为空)行 读写 char* fgets(char* c ,size_t l, FILE* f);  // 按照 行 和长度l 读文件f 到字符串char* c(配置文件),    返回从文件读取到的字符串.以换行符作为一行结束的标识 并且会自动补个0. int fputs(char*c , FILE*f );  // 把f 的内容写文件     返回值 0写入成功, 非0写入失败 块 读写 size_t fread(void* s,size_t l1,size_t l2,FIL E* f); // 从文件读取内容放到内存的内存元素首地址&(数组,结构都行),    l1 一块多大内存，l2 有多少个块(比如二位数组的列项数字，或者有多少个l1 ), f 写入的文件指针.    读文件  返回值  成功读入内存的块数目也就是 l2 的数目.  (主要用在大数据块迁移)   size_t fwrite(void* s,size_t l1,size_t l2,FIL E* f); // s写入文件内容元素首地址(数组,结构都行),l1 一块多大内存                               l2 有多少个块(比如二位数组的列项数字，或者有多少个l1 ), f 写入的文件指针.    写文件  返回值  成功写入文件的块数目也就是 l2 的数目.  (主要用在大数据块迁移)    格式化 读写 int fprintf(FILE*,char*); // 按照 格式化 进行写文件 ,返回写入成功的字符串的个数,和printf 类似. int fscanf(FILE*,char*);  // 按照 格式化 进行读文件 ,返回读取到的(%d,%f之类的)数据的个数.        文件指针操作 int fseek(FILE* f,long d,int n); // f文件指针,d偏移量,n参考点(宏定义:SEEK_SET 从文件开头移动d个字节,SEEK_CUR 从    当前位置移动d个字节, SEEK_END 从文件末尾移动d个字节).  返回值: 成功返回0,否则非0 并设置errno long ftell(FILE *f);  // 读取文件光标距离开头的位置.返回当前光标距离文件开头的字节数,出错则返回-1 并设置errno void rewind(FILE *f);   // 将文件光标放在文件开始的地方(无论光标目前在哪里).相当于fseek(f,0,SEEK_SET).文件打开 FILE* fopen("文件名","打开模式");  // 打开文件,失败会返回NULL (一般用这些 r+读写,w+覆盖读写,rb,wb,ab,r) int  fclose("已经打开文件的指针"); // 关闭已经打开的文件判断是否达到文件末尾 EOF bool feof(FILE* f);    // 如果达到文件末尾EOF则返回 true, 否则返回false, 经常用来!循环判断是否达到文件末尾. 刷新缓冲区 int fflush("文件指针");  // 刷新缓冲区,把缓冲区内容写入文件.(程序运行中输入的字符串都在缓冲区,没在文件里) 错误信息输出   perror("库函数");  // 打印错误信息,系统函数,如果函数错误就用这个函数打印.不可以在main函数内使用.清空数组内的数据 void* memset(void* s,int ch,size_t n);  // s 字符串,ch 替换值,n 需要替换的长度. 把s内的 n个长度元素变成 ch,    返回 s .  程序运行中输入的字符串都在缓冲区,没在文件里,但是一旦缓存区满了,就会把字符串写入文件内了.c 语言有三个特殊文件指针无需定义,打开可直接使用:  (类似于宏定义)    stdin (标准输入) 默认为当前终端(键盘), 我们使用scanf,getchar 函数默认从此终端获得数据.     stdout(标准输出) 我们使用的 printf,puts 函数默认输出信息到此终端    stderr(标准错误) 当我们程序出错或者使用 perror 函数时信息打印在此终端.        绝对路径和相对路径的区别:    绝对路径(win): c:\\Users\\apple\\a.txt       <只能用在win>    相对路径(全平台):   ./a.txt   (本目录)     ../b.txt （上个目录)     <建议用这个>    全平台通用路径: D:/data/xxx/q.txt             <这个兼容性最好,是绝对路径>        可以使用fopen()打开文件后,按行fgets()或者按块fread()来读取文件,然后使用 strstr()来查询字符串中需要的内容,   也可以直接fscanf()来获取需要的的定内容,但是应该用块.如果文件比较小的话,使用fseek()到结尾,然后使用ftell()确定文件大小,然后申请内存用块fread(,,1,)放进来,随意查找.    打开文本文件的话应该使用 rb+ 或者 wb+  使用二进制来修改和存放入内存(但是无法查看到明文内容),    如果要查看内容的话应该使用r+.            ----------------------------------------------------------------------------------------------------------------    宏定义:    #define    ID    #undef     ID   // ID宏定义不生效        条件编译:    #ifndef    ID   // 如果没定义 ID 则进入    #ifdef     ID   // 前面如果定义了 ID 则进入    #else           // 如果没定义则运行这里    #endif          // 正常#if结束语局        #define MAX2(a,b) (a)>(b)? (a): (b)           //宏定义两个数比较大小(经常出现在面试题,注意括号)    #define MAX3(a,b,c)  (a) >(MAX2(a,c)) ? (a) : (MAX2(b,c))     //只是替换不存在多次运行.三个数比较大小        #ifdef __cplusplus     // 条件编译  使c代码可以使用 c++编译器来执行和编译    extern "C";            // 如果成功则调用c++编译器的 c 编译器部分,如果没有那就说明用的是c编译器    {    #endif    ......        #ifdef __cplusplus    {    #endif                 //条件编译结束  , 一般用在头文件中的代码想用c 编译器的时候            #ifndef    ID    //  这是才是常用的    #else    #endif        链表:    (有头链表)(数据大于5个)    把一个双向链表写入文件,可以读取到内存,也可以排序然后存入文件,按照顺序读取,可以修改删除翻转插入    可以打印全部数据,可以任意添加节点,操纵文件.    双向链表反转(精髓)typedef struct Node{    num data;    struct Node * last;    struct Node * next}Node;typedef struct R_Node{    num data;    struct Node * next;    struct Node * last;}R_Node; // 使用内存模型进行反转.主要的一步就是强制类型转换 Node * p = (Node*)malloc(sizeof(Node));R_Node * rp = (R_Node*)malloc(sizeof(R_Node));rp = (*R_Node)p;// 访问rp就会得到反转的链表   // 指针是不会改变大小的(都是固定内存)假设ElemType是int那么struct node在内存中就是+----+----+----+| data  | perv | next |+----+----+----+而struct reverse_node在内存中就是那么struct node在内存中就是+----+----+----+| data  | next | perv |+----+----+----+________________________________________________________________________________________________________动态库封装 (不可以出现中文路径名称)    不需要主函数,只需要集团口头文件和接口实现文件就好了.     每个平台的封装动态库都是不一样的,要详细查阅.    windows::::: 这个平台会生成 .dll 文件     // windows 的 vs 平台下  使用__declspec(dllexport) 这个 宏 来实现动态库(死规定)    // 需要在 项目属性中->项目默认值->配置类型:(动态库dll) , 目标拓展名:(dll).    // 这样才能生产成功    __declspec(dllexport)void fun(void){    std::cout << std::endl << "fun \n" << std::endl;}        // 直接把 宏 添加到 函数实现 开头就好了.然后选择编译就可以 ,会生成dll    // 可以没有头文件,但是还是得写,然后详细记录后给提供给用户     生成后会出现 .dll 和 .lib 这两个主要的文件,    .dll 是程序运行时候需要(大部分应用都是这样的),编译的时候可以不用   .lib 是编译的时候需要(要放在同一个文件夹内,运行还是得要dll),里面记录了 dll 内包含的函数.   .h 的头文件也要提供,就是告诉这个动态库里面都有什么函数,给用户提供一个声明. 使用:    首先创建工程,然后 .lib 和 .h 文件放在工程 main.c 的文件同目录下,    然后把 .h 添加到工程头文件中,    接着打开 项目属性 -> 配置属性 -> 链接器 -> 输入 -> 附加依赖项:(添加 .lib文件名).    这样就可以通过编译,但是运行的时候还是需要把.dll放入到工程文件内.    但是单独的运行 .exe 则要把 .dll 两项都放在一起,才可以正常运行.                >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Linux::::::: 这个平台下生成的是 .so  文件  Linux动态库生成与使用指南相关阅读: Linux静态库生成指南Linux下动态库文件的文件名形如 libxxx.so，其中so是 Shared Object 的缩写，即可以共享的目标文件。在链接动态库生成可执行文件时，并不会把动态库的代码复制到执行文件中，而是在执行文件中记录对动态库的引用。程序执行时，再去加载动态库文件。如果动态库已经加载，则不必重复加载，从而能节省内存空间。Linux下生成和使用动态库的步骤如下：编写源文件。1, 将一个或几个源文件编译链接，生成共享库。2, 通过 -L<path> -lxxx 的gcc选项链接生成的libxxx.so。3, 把libxxx.so放入链接库的标准路径，或指定 LD_LIBRARY_PATH，才能运行链接了libxxx.so的程序。4, 下面通过实例详细讲解。编写源文件建立一个源文件： max.c，代码如下：----------------------------------------------int max(int n1, int n2, int n3){    int max_num = n1;    max_num = max_num < n2? n2: max_num;    max_num = max_num < n3? n3: max_num;    return max_num;}-----------------------------------------------编译生成共享库：gcc -fPIC -shared -o libmax.so max.c 我们会得到libmax.so。 实际上上述过程分为编译和链接两步， -fPIC是编译选项，PIC是 Position Independent Code 的缩写，    表示要生成位置无关的代码，这是动态库需要的特性； -shared是链接选项，告诉gcc生成动态库而不是可执行文件。 上述的一行命令等同于： gcc -c -fPIC max.c gcc -shared -o libmax.so max.o 为动态库编写接口文件 为了让用户知道我们的动态库中有哪些接口可用，我们需要编写对应的头文件。  建立 max.h ，输入以下代码：---------------------------------#ifndef __MAX_H__#define __MAX_H__int max(int n1, int n2, int n3);#endif----------------------------------测试，链接动态库生成可执行文件建立一个使用max函数的test.c，代码如下：------------------------------------------------------------------#include <stdio.h>#include "max.h"int main(int argc, char *argv[]){    int a = 10, b = -2, c = 100;    printf("max among 10, -2 and 100 is %d.\n", max(a, b, c));    return 0;}-------------------------------------------------------------------gcc test.c -L. -lmax 生成a.out，其中-lmax表示要链接libmax.so。-L.表示搜索要链接的库文件时包含当前路径。注意，如果同一目录下同时存在同名的动态库和静态库，比如 libmax.so 和 libmax.a 都在当前路径下，则gcc会优先链接动态库。运行运行 ./a.out 会得到以下的错误提示。./a.out: error while loading shared libraries: libmax.so: cannot open shared object file: No such file or directory找不到libmax.so，原来Linux是通过 /etc/ld.so.cache 文件搜寻要链接的动态库的。而 /etc/ld.so.cache 是 ldconfig 程序读取 /etc/ld.so.conf 文件生成的。（注意， /etc/ld.so.conf 中并不必包含 /lib 和 /usr/lib，ldconfig程序会自动搜索这两个目录）如果我们把 libmax.so 所在的路径添加到 /etc/ld.so.conf 中，再以root权限运行 ldconfig 程序，更新 /etc/ld.so.cache ，a.out运行时，就可以找到 libmax.so。但作为一个简单的测试例子，让我们改动系统的东西，似乎不太合适。还有另一种简单的方法，就是为a.out指定 LD_LIBRARY_PATH。LD_LIBRARY_PATH=. ./a.out程序就能正常运行了。LD_LIBRARY_PATH=. 是告诉 a.out，先在当前路径寻找链接的动态库。对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的 DT_RPATH 段, 环境变量 LD_LIBRARY_PATH, /etc/ld.so.cache文件列表, /lib/,/usr/lib目录, 找到库文件后将其载入内存.makefile让工作自动化编写makefile，内容如下：----------------------------------.PHONY: build test cleanbuild: libmax.solibmax.so: max.o    gcc -o $@  -shared $<max.o: max.c    gcc -c -fPIC $<test: a.outa.out: test.c libmax.so    gcc test.c -L. -lmax    LD_LIBRARY_PATH=. ./a.outclean:    rm -f *.o *.so a.out----------------------------------make build就会生成libmax.so， make test就会生成a.out并执行，make clean会清理编译和测试结果。      >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UNIX_MAC:::::: 这个平台下生成的是  so 和 dylib 文件//  创建实例// 通过命令行来实现,需要gcc, 而不是xcode, 一般来说其他的ide 也差不多 //下面是 add.cppint add(int a, int b){    return a + b;}// 下面hi main.cpp#include<stdio.h>int add(int a, int b);int main(){    printf("%d\n", add(1,2));    return 0;}//编译成静态库所需要的命令和流程$ gcc -c -o add.o add.cpp$ ar -r libadd.a add.o$ gcc -o main -L. -ladd main.cpp$ ./main//编译成动态库所需要的命令和流程$ gcc -shared -fPIC -o libadd.so add.cpp$ gcc -o main -L. -ladd main.cpp$ ./main我对动态库的一个理解是： 第一次编译时需要libadd.so参与编译 而第一次编完后，如果main.cpp不改动，add.cpp改动，那么不需要重新编译整个main，只需要重新编译libadd.so，替换原来的libadd.so即可运行main。 .备注 鉴于链接静态库和动态库的命令是一样的，系统会优先链接动态库。--------------------------------------------------------------------------------------------------------常用开发工具使用:大项目一定会用到的;   日志打印:(开头有范例)--------------------------------------------------------------------------------------------------------