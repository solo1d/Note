本笔记所有关键字:
enum ,inline ,public ,private ,protected ,virtual ,friend ,operator 
枚举  ,内联   ,公有    ,私有     ,保护      ,虚或纯虚  ,友元   ,操作符重载



 ! 在 c 下函数的默认返回值是int, 就算是 f(){xxx} 这样写在那里,也不会出错.但是c++下不行.
 ! 在 c 下可以重定义多个同名的全局变量,会存在不同的字段(无初始化会在bss,有初始化会在data).c++下不行.
 ! 一个函数的返回值就是一个无名的隐藏变量,一旦当接受它的是一个想要用它来定义的初始化的值的时候,
       它会直接由无名隐藏变成那个值的名字,从而顶替他.(这个很重要,尤其是类的时候,这样来定义一个类是不
        会触发析构函数的!)

 双目(也称双元)运算就是运算符有两个参数,(a + b  中的 + 就是双目运算符).
 三目运算符这样写就可以变成左值:   (开发根本用不到)
    *(a < b ? &a :&b) = 50;     // 如果a小于b 则返回a 的引用,然后修改a的值,反之亦然.
     (a < b ?  a : b) = 50;     // 同上,三目运算返回的是变量的引用,并不是返回某个数值,这样是可以的.

 const int a; 等价于 int const b;  没区别的.
 
 const 类型的常量会在 常量区的符号表创建,而不是在栈区.没有地址(而且还会在编译阶段把常量换成值)
 符号表有可能在常量区有可能在text段(去找内存笔记);
    符号表纯粹是一个阵队, 一个是 key (存放变量名称) 一个是 value(存放变量数据),没有空间和地址,
        而且是只读不可修改的.会在编译的时候替换(不是预处理),与#define 虽然很像但不是一个东西.


!!! 如果对一个常量取地址,编译器会临时开辟一个空间(栈),让这个指针指向存放这临时空间的地址.
     (当然,这个临时空间内的值也就失去了常量的性质,变成 变量了,可以随意更改.但是和原常量没关系了).



 enum 枚举类型范式:
    enum Season{ ziro = 0, one , two };   //声明
    int main(void)
    {
        enum Season vod = one;  // 定义了 vod 等于 one 代表的值 也就是1
        if (vod == one )    // 尽量来这样比较和使用
        { 
           ......
        }
    }
        
 左值 可以在多行使用, 如果不是const的左值,那么就可以随意修改,如果是const  则不可以修改. 
 右值 就是一个临时变量, 只能在当前行使用,而且不可以进行直接的引用.(在C++11标准中可以&&来对引用,取地址)
  
 关于引用中的左值引用和右值引用, & 一个引用符号是左值引用, && 是右值引用,这个右值引用解决了模版的一些问题,如果遇到问题可以尝试.
 右值引用可以解决以下形式类似的问题:(尤其是存在重载的时候,这个时候要运行试一试)
  void func(int&& x){ cout << x << endl; }  //传入值是一个int
  func(3);  //可以直接传入常量,而不是一个对象.(如果不提供 func(int&&),那么会调用 func(const int &))
  // 当然这是有重载的时候发生的情况.
    
 引用的本质就是 type * const T_Nmae;   就是个指针常量,不能修改指向.
    如果我们去研究引用的时候,可以把引用当做一个常指针去研究,
    无法引用右值,比如 100 这个数值是不可以直接引用的,但是却可以 双重引用 使用两个&&符号来对引用,取地址. 
    当我们在使用引用编程的时候,你就可以把引用理解为变量的别名就可以了.
    把引用当做超级指针来看最好.
    还有种比较绕口的: (就是一个指针的引用)
        struct cer { int i;};  //一个结构
        int fun(struct cer* &tmp)  // 一个函数  形参是结构类型的指针的引用
        {  tmp = (struct cer*)malloc(sizeof(struct cer)); } // 直接就可以当申请内存当指针


 内联函数 inline  ;
 
 占位参数:存在于函数形参列表中,主要用途是 亚元 ,其实就是一个没有任何意义的参数,为了占位置.
    例;  
    int fun(int a,int b,int);    // 第三个参数是用不到的,但是调用的时候还是得传递参数.
    int fun(int a,int b,int = 0);    // 与上面相同只不过有个默认参数.


 函数重载:
    函数的返回值,函数形参列表(参数的个数,参数的类型,参数顺序);
    函数重载, 函数名相同, 参数列表不一样,参数个数不同.
    函数返回值并不是构成函数重载的条件.
    (在c 中实际这重载函数并不是同样的文件名,都是被更改过的,然后去替换)
    
   实现原理:用v c i f l d 表示 void,char,int,float,long,doube以及其他引用,然后写入函数名后.
    void func(char a) ;    //在编译时候就变成了, func_c(char a);
    int  func(int a, double b,char c);   //在编译时候就变成了, func_idc(int a, double b,char c);
    

    
    
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

bss段:
    bss段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域.
    bss是英文Block Started by Symbol的简称。BSS段属于静态内存分配. 
    bss段用来分配未初始化（或初始化为0）的全局变量和静态变量.
    
data段:
    数据段 (data segment) 通常是指用来存放程序中已初始化的全局变量的一块内存区域.
    数据段属于静态内存分配.
    
text段:
    代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域.
    这部分区域的大小在程序运行前就已经确定,并且内存区域通常属于只读(某些架构也允许代码段为可写,即允许修改程序).
    在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等.

堆（heap）：
　　堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。
　　当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）.
　　当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。

栈(stack)：
　　栈又称堆栈，是用户存放程序临时创建的局部变量，
　　也就是函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）.
　　除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中.
　　由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。
　　从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

一个程序本质上都是由 bss段、data段、text段三个组成的。

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
内存顺序:
    最高位内存-> 内核 , 栈(占用最大) , bss(很小), data(很小紧挨着bss), text(垫底) ->最低位内存

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

(int char double long 之类的这样的关键字都是类)
类 : class temp { 
    public:    // 公有成员
    private:   // 私有成员
    protected: // 保护控制权限.在类的继承中跟private有区别,再单个类中,跟private一样.
};
!构造函数和析构函数都不允许有返回值.(定义的时候都没有那么就不应该有).

!构造对象成员的顺序跟初始化列表的顺序无关,而是跟成员对象的定义顺序有关.

!析构函数不能有形参,而且析构也不能重载, 但是构造可以重载.

!当有显示的构造函数或者显示拷贝构造函数的时候,默认无参构造函数都会被屏蔽.(但是默认拷贝构造函数还有).

!类的声明周期结束后会调用析构函数,如果函数中有多个类,那么会实行先入后出原则,最后构造的先析构(出栈).

!临时创建的无名类,定义以后会立刻析构(temp(); 运行过了这一行就立刻析构,就是刚刚定义就没了).

!成员函数尾部出现 const ,修饰是 this 指针.(const temp *cosnt this).

!this 指针原型( temp *const this);

!一个 const 的指针,当把它传递给其他函数形参的时候,接受它的也必须是 const 类型,否则会出现安全问题,编译也无法通过.

!定义类函数的时候都会隐藏的传入一个 this 指针常量 隐藏参数.

!如果想返回一个对象的本身,在成员方法中,用 *this 返回.

!如果想对一个对象相续调用成员方法,每次都会改变对象本身,成员方法需要返回引用.


--------------- 
  构造函数:
    构造函数 是生成(定义)时候触发,析构是结束时触发.
    构造函数 需要在 public 内:
    temp (int t, int a):t1(t),a1(a) {/*这里面可有可无*/ }

! 使用 new 和 delete 会自动调用构造和析构的,
!!! 无论什么情况都要把 = 号操作重载和 深拷贝构造 两个重要的成员写出来.
 
 
--------------- 
  析构函数:
    析构函数也要在 public 内:
    ~temp() { //里面是用来释放内存之类的操作 }

 ! 一个函数的返回值就是一个无名的隐藏变量,一旦当接受它的是一个想要用它来定义的初始化的值的时候,
       它会直接用无名隐藏变成那个值的名字,从而顶替他.(,这样来定义一个类是不会触发析构函数的!)
 ! 使用 new 和 delete 会自动调用构造和析构的,
 ! memset();  该函数可把数组内的所有元素都初始化为 '\0'
 
---------------   
  拷贝构造函数:
    拷贝构造函数也在 pubilc 内:  (多多注意深拷贝和浅拷贝以及内存分配问题)
    temp(cosnt & tempthis) { this->t1 = tempthis.t1; this->a1 = tempthis.a1;}  //浅拷贝
    这个拷贝构造函数在使用的时候有两种调用方式:
        temp t1;  
        temp t2 = t1;   
        temp t3(t1);
        temp t4;
        t4 = t3;
        void tempfun(temp t);
        // 函数形参的值传进来也会调用拷贝构造
        // 这几种种赋值方式都会调用同一个拷贝构造函数,所以他们是等价的.
       
    !!但是这么写就不是调用拷贝构造函数了,而是调用 赋值操作符重载.
        temp t4 , t5 ;     //他们已经调用了构造函数了.
        t4 = t5;     // 他们调用的是 赋值操作符,跟拷贝函数没关系.
        t4(t1);      // 这样调用也是不可以的,他调用的是一个函数成员而不是拷贝构造.
!!!!    t5 = add();  // add()返回一个 temp 类, 返回值会调用操作符重载,然后析构掉,t5就会得到它的值
                     //                                (!而不是拷贝构造!)

!!! 无论什么情况都要把 = 号操作重载和 深拷贝构造 两个重要的成员写出来.
 
 
--------------- 
  友元函数: (友元不是定义而是声明)
        friend double Point();    // 使 point() 函数成为temp 类的友元 (原型 double Point()).
        friend class ent;     // 声明一个友元类
        friend double ent::Poble();   // 使 ent 类中的成员函数 Poble() ,成为temp类的友元.

 ! 友元声明写在类内的任何地方都可以,因为仅仅只是声明.
 ! 友元可以直接访问类内的私有成员.
 ! 友元的作用是提高了程序的运行效率(即减少了类型检查和安全性检查等都需要时间开销).
 ! 友元的弊端: 破坏了类的封装和隐蔽性,使得非成员函数可以访问类的私有成员.
 ! 同类对象间无私处,异类之间有友元.
 ! 友元关系不能被继承. 
 ! 友元类是单向访问的,(temp 声明了 ent的类, ent 可以随意访问 temp, 但是temp 不可以访问 ent).
 ! 友元没有传递性,(若类B 是类A 的友元,类C 是类B 的友元,则类C 不一定是类A 的友元,同样要看类中是否有相应声明).
 ! 不建议使用 !!


------------------------------
  操作符重载: (传入参数 第一个是符号前面的 ,第二个是符号后面的,如果在类内 this 会成为第一个,后传入是第二个)
              (如果传入两个和this不相干的参数(比如cout,c1) 则可以不理会this,  而且 cout 会成为第一个 c1第二个)
              (不可以修改操作符的使用规则  cout << c1; 不能修改为 c1.operator(cout);  绝对不能!!!!)
        temp operator+(temp &p){ //操作符重载类内部标准模版 operator+ 构成函数名,中间不能有空格  
           temp p1 
           p1.a = this->a + p.a;       // 注意一下类的构造函数
           p1.b = this->b + p.b;
           return p1;      //内部实现细节,同类相同,返回一个 temp 类的值
        } 
        
        friend temp& operator+=(temp& p1, temp& p2){ // += 操作 要写在外面然后用友元函数声明到类内
            p1.a +=  p2.a;  
            p1.b +=  p2.b;  
            return p1;
        } // 写在类外 全局函数
        
       temp& operator-=(temp& p){  //为了修改本身 那么需要返回引用  别忘了会有一个隐藏的this指针参数
           this->a += p.a;
           this->b += p.b;
           return *this;
       } // 写在类内的重载 -= 运算符
       
       
! ++ 运算符++可以在前可以在后,如果多次++ 则必须在前,不能在后(++++a;可以, a++++; 不可以)
!    想要重载则必须使用.函数重载. 来区分表示前++ 和后++.
!    如果想重载这个运算符,就应该把前++ 和后++ 都写上就最好了.

       temp& operator++(){    // 类内 重载的是前置++  先加 后使用 ,可以连加,全局的一个参数,类内局部的没有参参数
           this->a++;         //
           this->b++;
           return *this;
       }
       
       //重载后++ 则必须需要一个占位符来占坑,
       const temp operator++(temp &p1,int){ //全局.出现了占位符.重载的后置++先使用 后加,不可以连加,所以出现cosnt
           temp p(p1.a,p1.b);  //temp有个构造函数,把p1的值赋给 p
           p1.a ++;
           p1.b ++;
           return p;     // 返回的是那个临时变量,但是p1已经修改,然后用未修改的p 去参加后续的运算
       }
       
       
! << >> 最为常用的左移右移操作符 重载: (!!只能写在全局,绝对不要写在类内!!)
        (cout 的类型是 ostream, cin 的类型是 istream);
        
        ostream& operator<<(ostream &os, temp &p){     // 重载左移运算符(一般是cout),必须写在全局,不能写在类内!
            os<<"temp.a = " << p.a << ", temp.b = "<< p.b << endl;
            return os;     // 这个返回值是代表可以连续输入,比如这样调用 cout<< p << p1 << p2 << endl;
        }
        
        istream& operator>>(istream *is,temp &p){      // 重载右移运算符(一般是cin),必须写在全局,不能写在类内!
            if(
            
            cout << "a = ";     // 要提示一下要输入什么 更详细更好
            is >> p.a;
            cout << "b = ";     // 要提示一下要输入什么 能详细更好
            is >> p.b;
            return is;      // 这个返回值是代表可以连续输入,比如这样调用 cin >> p >> p1 >> p2 >> endl; 
        }
       
       
! = 重载等号运算符的时候需要多多注意 内存空间和 自身赋值(尤其是有指针的时候),以及深拷贝(小心内存泄漏)
        temp& operator=(const temp &another){     // 在类内重载 等号 运算符
            if (this == &another){   // 防止自身赋值需要判断地址
                return *this;
            }
            
            // 先将自身的额外开辟的空间回收掉,数据也要清空(也可能会出现特殊情况),要不然就会发生内存泄漏
            if(this->name != NULL){    // 比如temp 中有个name 成员 是个char类型的指针,而且分配了空间.
                delete[] this->name;   // 回收 name 指向的空间
                this->name = NULL;
                this->a = 0; this->b = 0;
            }
    
            // 执行深拷贝
            this->a = another.a; this->b = another.b;
            
            size_t len = strlen(another.name);   // 得到指针指向的内容的长度
            this->name = new char[len+1];     // 开辟一个堆空间 len + 1 
            strcpy(this->name,anoter.name);   // 如果无法使用strcpy 则可以使用其他C++的方式,但是 要的是副本
                                              // 而不是指针的地址,一定要拷贝而不是间接指向!!!
            return *this;               
        }  // 这是在类内的方案,在全局的话就


        friend temp operator+(temp &p1, temp &p2);   //操作符重载 类外部标准模版,需要使用 friend 友元
        temp operator-(temp &p1, temp &p2);   // 减法原型,就算连减也可以,只不过是括号的替换方式不同罢了.
        
        temp p = p1 + p2;  /*等价于*/  temp p = operator+(p1,p2);  // 内部替换
        temp p = p1 - p2 - p3; /*运算规则是*/ temp p = operator-(operator-(p1,p2),p3);   //替换规则
        
        
! [] 重载 数组运算符.
        int & operator[](int n){   // 想要那个数组数据就返回哪种类型
            if(n >= arr_len){         // 假设 arr是 temp 类中的一个int类型数组,长度为arr_len;
                cout << "越界" << endl;       //判断一下是否越界
                return -1;
            }                   // arr 是int类型的数组
            return this->arr[n];    //因为返回值是引用所以 , 返回的是内存块的别名  ,可以直接修改
        }
        
! () 重载小括号:(经常用在sql内)
        int operator()(int n){    // 第一个括号是运算符重载,第二个是需要传入的参数
            return this->a * n;   // 随便写的,这些东西基本上都会用在sql内使用,而且各种各样的重载版本
        }  
        
  ! 调用范例和误区: temp s(10);    // 调用的是构造函数 ,和重载无关.
  !                 int a = s(10); // 调用的是重载运算符,返回一个int
  
       ! 将一个对象当成一个普通函数来调用. 只要适当的修改形参的数量和类型就可以达到重载函数的作用.
       ! 称这种行为的对象是 仿函数, 伪函数,或者 函数对象 .  三个名字.


!new delete 重载操作符: (new 应该返回一个万能指针),这里可以在operatou和 new delete 中间出现空格.
---     void* operator new(size_t size){   // 返回一个指向内存的万能指针.
            return malloc(size);     // 虽然只是使用了malloc 来代替,但是可以触发 构造函数 来给类分配空间和值 !!
        }
        
       ! 调用范式: temp* p = new temp(10);  // 申请内存空间 ,调用 形参为一个int的构造函数.
                    // 原型: temp p(temp->operator new(sizeof(temp)))(10);
                    temp* p1= new temp;      // 申请内存空间 ,调用一次 默认构造函数.
                    temp* p2= new temp[10];  // 申请内存空间 ,调用10次默认构造函数. 和new 的重载函数无关.

---     void* operator new[](size_t size){
             return malloc(size);           //虽然声明不一样,但是内容相同
            
        }
        
        ! 调用范式: temp* p = new temp[20];     // 这是个数组 有20个元素,使用的是 默认无参构造函数,无法改变.
            // 原型: p->operator new[](sizeof(temp[20]));    //会触发 20次默认构造
            // 但是需要 operator delete[](void* p);  来释放,  因为new[] 数组 就需要 delete[]  这是定则.
                                
                            
---     void operator delete(void *p){   // 因为上面申请的是一个void指针,所以这里也用void也更好.
            if(p != NULL){               // 也会触发 析构  !!!!
                free(p);                // 因为new 是给类来分配空间 ,所以直接释放类就好了.
                p =  NULL;  
            }
        }
        
---      void operator delete[](void *p){   // 与上面的 new[] 来对应,要不然可没法析构数组new[] 了
               if(p != NULL){               // 也会触发 析构  !!!!
                free(p);                // 因为new 是给类来分配空间 ,所以直接释放类就好了.
                p =  NULL;  
            }
        }
        
        ! 调用范式: delete p;     // 直接定义的p 直接释放.
                    delete [] p2;  // 因为是数组所以这样来释放,一一对应,因为p2有10个元素,就会触发10次析构
                    
                    
!&& || 操作符重载:(别用,不能和正常操作符有用一种操作,而且不稳定,也可能会出现编译报错)


        
 ! operator+ 构成函数名,中间不能有空格,而且可以写在全局也可以写在类内部.
 ! 操作符重载的返回值一定要小心,尽量返回一个值,而不是引用(引用很少很少用).
 ! c++不允许用户自定义新的运算符,只能对已有的c++运算符进行重载.
 ! 很多运算符都可以重载,但是 .()成员选择 .*(成员对象选择)  ::(域解析) ?:(条件操作符)这四个运算符不可以重载定义.
 ! 不允许改变原有操作符的基本意思,以及运算符需要的对象数量.( 比如 a+b 需要a和b  但是a+ 放这里就意义不明了).
 ! 当重载了 + 和* 运算符之后,c++还是按照 先算乘除 *  后算加减来进行运算的.不能改变运算符的优先级别.
 ! 重载不能改变运算符的结合性.(如 赋值运算符"=" 是右结合性(自右向左),重载后仍为右结合性).
 ! 重载运算符的函数形参不可以出现默认的参数.(temp operator+(temp &p1,temp &p2 = 0); //这样是不可以的
 ! 重载运算符必须和用户定义的自定义类型的对象一起使用,其参数至少应有一个是类对象(或类对象的引用).
 ! 重载运算符不可以曲解原先运算符的本意( a + b 为加法,  不可以出现重载为减法的样式).
 ! 运算符重载函数可以写在类内,也可以写在类外然后变成类的友元函数,都是可以的.
 ! 重载双目运算就是运算符有两个参数,(a + b  中的 + 就是双目运算符).
 !!! 无论什么情况都要把 = 号操作重载和 深拷贝构造 两个重要的成员写出来.
 
--------------- 
  静态成员变量和静态成员函数:(类中的静态成员存在 静态区(全局区),其他的保留c原则,静态函数是文件作用域)
        static int a;   //如果a存在pubilc 中则外部可以访问,如果是private 则外部不可以访问.不可以在类内初始化
        static const int b = 10;    // 常量的静态成员是可以在类内初始化的,如果不是常量则不可以.
        static int& num(int a1,int b1);   // 这个成员函数可以访问内部静态成员,并且返回一个静态int类型的引用.
                                          // 这样写就可以当成左值进行修改返回的内部静态成员.
                                          
        temp::num() = 300;  // 在类外可以这样来进行对静态成员的赋值,前提是返回的是类内的静态成员.
                                          
        int temp::a = 19;   // 在类外,在temp第一个定义之前,这样来进行初始化,pubilc和private都可以这样来初始化.
        
! 静态成员变量只能使用静态成员函数来访问和修改.(不是初始化)
! 静态成员常量可以在类内初始化.
! 静态成员在类外,在temp第一个定义之前,pubilc和private都可以用类作用域来初始化.
! 静态成员是属于类的,不是属于类的对象的,对象之间共享同一个静态成员.
! 静态成员不可以使用构造来进行初始化!!
! static 成员类外存储,求类大小,并不包含在内.
! static 成员是命名空间属于类的全局变量,存储在 data 区.
! static 成员函数,只能返回static成员变量,无法返回非static的成员.
        

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
new 和 delete   (是运算符,而不是函数,运算符比函数执行效率高)
    int *p = new int;    //标准范式
    int *a = new int (10);   //创建一个int类型的a 赋值为10
    int *array = new int[10];    // 创建一个有10个元素的int类型数组
    temp * tp = new temp(10,10);     // 在堆上申请空间,使用new 并且可以调用构造函数. 
                                     // 实际就是定义了一个类的指针,并且使用构造函数初始化了.
    temp * tp1 = new temp[5];     // 创建了一个类的数组指针,并且其中有5个元素,每个元素都指向一个类.
                                  // 使用默认构造函数.
    
    delete p;        // 释放一个int
    delete[] array;    //释放一个数组,必须要这样写
    delete tp;     // 释放一个类的指针,并且触发析构函数
    
! malloc() 和 free()  是函数,标准库,来自stdlib.h   malloc.h
! new 和 delete   是操作符, c++整合进入标准库的  iostream
! new 在对上初始化对象的时候可以触发构造函数,但是 malloc 却不可以初始化对象,而且这属于c 并不应该用在c++中.
! delete 在释放类的时候会自动调用析构函数,防止内存泄漏, 但是free()是不会调用析构,类里面申请的独立空间就会无法释放.
! 有一个 new 操作就需要一个 delete , 有一个 new[] 就需要 delete[].  (运算规则)
! new 做了三件事: 1) 找一块内存,并返回地址.
                 2) 将这块内存转换为需要的类型.
                  2) 在这块内存上构建类对象.也就是调用构造函数.
            
            
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

!智能指针: 需要头文件 <memory>, 实际上智能指针就是一个类,   //智能指针会自动回收空间
! auto_ptr<> ; 已经弃用了. 现在的替代方案是 shared_ptr<>  //使用方法和 auto_ptr<>差不多.

! 普通指针的三个必要素: 1) 定义一个指针,指针要指向一个变量.
                     2) 建立关联.
                     3) 开辟空间,间接赋值.
 普通指针:  A* pa = new A(10);   // A是个类,调用了形参int的构造函数,
 
!智能指针: shared_ptr<int>    // 写到这里表示 这是一个指向 int 类型的智能指针,这是数据类型.不是变量
          shared_ptr<A> ptr(new A(10));   //创建一个智能指针,叫ptr(就是个对象),接收一个 new A 的指针(不能写等号) 
           // ptr 是变量名.()括号内的是地址, 调用的是它的构造函数, ptr就指向 (new A)的地址.
           // 然后 (10) 来调用类 A 中的int 个构造函数来初始化. 返回地址给 ptr.

!   使用: *pte = 20;    // 跟正常指针差不多. 但是不需要 delete 来释放空间,他会在结束后自动调用自身的析构函数.
         
!通过重载 -> 和 * 解指针 来自定义智能指针.(能用模板的话就要强纽成相应的类型来释放空间,不可以使用void* 来释放,坑)!





>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
类的派生和继承:  ! 基类 = 父类     子类 = 派生类    
! 派生的关键字 public(公有继承)  和类中的 public(公有成员) 不是一个含义!
! 派生关键 public 表示继承方式(公有继承).  类中的 public 表示的是访问权限.
! 派生类中的成员,包含两大部分,一类是从基类继承过来的,一类是自己增加的成员,
      从基类继承过 过来的变现其共性,而新增的成员体现了其个性.
! 父类中的构造函数是无法继承下来的**

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 派生类成员的标识和访问权限:         
                     public.    protected.  private     // 公有成员 还是可以正常修改和访问的,
公有继承(public)     public,    protected,  不可见.  // 拥有继承下来的私有成员,但是不可以显示的更改,只能通过父类.
保护继承(protected)  protected, protected,  不可见.  // 修改了作用域,不能在类外显示的使用成员,类内可以显示调用.
私有继承(private)    private,   private,    不可见.  // 全部变成私有,类内可以显示更改,外部不可以显示修改.


!规则1, 只要是基类中的 private 成员,不管是什么继承方式,继承类都不可以访问,但是成员还是存在的,内存中有这个成员的.!
!规则2, 如果是公有继承(public), 派生类中的访问控制权限保持不变,其他和规则1 相同.
!规则3, 如果是保护继承(protected), 派生类中 基类中除了private成员,其余的都会变成 protected 成员.
!规则4, 如果是私有(private)继承,派生类中的基类的除了private 成员,其余在派生类中都是private成员.

分析用的三看原则:
 1,看调用的成员变量是在类的内部还是类的外部.
 2,看派生类的继承方式.
 3,看当前变量在派生类中的变量在基类的访问控制权限.
 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


class A{
    public:
           void funcA(){ cout << "funcA" << endl;}
   private:
        int a;
}

class B{
    public:
           void funcB(){ cout << "funcB" << endl;}
   private:
            A a;
}

class C{
    public:
           void funcC(A* a){ cout << "funcB" << endl;}

};

class D:protected A{       //类D 继承于类A , 表示A里面有什么那么D里面就有什么,跟复制一样
    public:
           void funD(){
                cout << a << endl;   //直接就可以使用 a
            }
};

class E:private : A,B{ ...  };   // E 继承了A 和B , 称为 A和B 的派生类(多继承)
    

! 耦合度 : 高内聚  低耦合   // 程序追求的最好的结果
          高内聚: 一个函数只干一件事,函数的功能越单一越好.
          低耦合: 一个函数和另一个函数的关联度越低越好.
! 类和类之间有三种关系 : [B has A] , [C uses A], [D is A(继承)].
! 类 B 拥有类A 的成员变量,称作 B has A ,  // 类B 依赖于 类A
! 类 C 的成员方法, 需要类A 的形参, 称作 C uses A,  //类C 依赖于 类A    耦合度小于类B,对A的需求较少
! 类 D 继承于类A , 类D 如果是继承类A ,读作类 D is A   // D继承与A, 耦合度很高
! 类 E 继承于类A , 类B ,也称为派生类,只不过是多继承.
! 类 D 继承于类A , 是单继承.


-------------------------
继承:
class Stu1 {  // 这是个类内部有很多内容 // stu1 被称作基类(也成为父类)
public:
    Stu1(int id, string name){
        this->id = id;
        this->name = name;
    }
    
    void printS(){
        cout << "id = " << this->id << ", name = " << this->name << endl;
    }
private:
    int id;
    string name;
}; 
class Stu2 :public Stu1{   //继承的标准语法,  stu1 被称作基类(也成为父类) , stu2 被称作派生类(子类)
public:
    Stu2(int id1,string name1,int score):Stu1(id1,name1)   //委托构造函数,委托父类的构造去构造父类的成员.
    {                                                      //会先调用父类的构造,然后才是子类的,
        this->score = score;                               //如果不是显示调用父类构造,则触发父类的默认构造
    }
    
    void printS(){
        Stu1::printS();   // 调用了基类中的函数成员, 要使用作用域
        cout << "socre = " << this->score << endl;
    
private:
    int score;
}



! c++中的可重用性(software reusability)是通过继承(inheritance)这一机制来实现的.*继承性必须掌握!
! 父类和子类分别创建对象的时候,内存完全是独立的,毫无关系.顶多就是代码共享.
! 子类内存中有父类的布局,而且是用父类的构造函数构造的,但是和父类没关系,可以看做把父类的东西放入子类,然后子类来使用.
! 子类永远比父类占用的内存大.
! *在调用子类的构造函数的时候,一定会调用父类的构造函数,父类先构造,子类后构造. 析构是子类先析构,父类后析构.
! 如果在子类中有成员与父类成员名相同,而且都是public成员,那么应该通过 :: 作用域来访问父类中相同类型名的值.(私有的话不行).
! * static 的成员是对整个家族都共享的,无论是哪个子类访问的都是同一个全局静态区的内容.(一个子类修改,那么全部的改变了).

! 子类对象可以当作父类对象使用.(因为子类中拥有父类所有的内容,内存块也有和父类相同的地方).
! 子类对象可以直接赋值给父类对象. (只是拿出子类的中父类的内存块来给父类赋值).
! * 父类指针可以指向子类对象 ( 因为内存块的结构,而且子类中拥有父类中的所有内容,所以那一块内存结构相同).
! 父类引用可以直接引用子类对象.(和指针相同).
! 定义一个接口,引用一个父类的对象,那么所有的子类都可以直接传递进入,(相当方便,可以看成是整个类家族中的万能指针).
! 绝对不可以用父类指向子类的指针 进行++ , 来遍历子类对象数组.


---------------------------------------
多继承中的虚继承:
    class Stu{ int m; };  //父类有个 m
    class Stu2:public Stu{};   // 这个子类继承后也会出现一个父类中的 m 
    class Stu3:public Stu{};   // 这个子类继承后也会出现一个父类中的 m , 目前和 Stu2 没关系 
    class Stu4:public Stu2,public Stu3{};   // 这个子类继承了Stu2和Stu3,那么会出现两个父类的两个 m
                                            // 此时出现了虚继承,因为继承了Stu 两次
    
    解决方法:
        class Stu{ int m; };  // 第一个父类(基类) 是不需要添加关键字 virtual 的 
        class Stu2: virtual public Stu{};  // 添加关键字 virtual  这是第一代子类,添加是为了第二代的子类
        class Stu3: virtual public Stu{};  // 这个也需要添加关键字, 除非认为这个类不会再有子类了.
        class Stu4: virtual public Stu2,public Stu3 {}; // 这样Stu4 中将只有一个 m 类了,这个m 是 Stu 里面的.


! 多继承可能会出现虚继承,造成访问不明确.(一般的解决方法是 添加作用域.Stu4 a.Stu2::m = 10; //使用Sut2的 m).
! 关键字 virtual 除了第一代的基类(第一个没有继承的那个类),剩下的子类都要尽可能的添加,以避免虚继承.
! 添加关键字之后 m 这个成员是复制的第一个出现 m 这个类型的类,认为他就是这个m 的基类,而无论是不是继承 祖宗中的.
      内存格式的开头就是祖宗的类的格式.

---------------------------------------
~析构函数也可以触发多态,而且还是重要:

    class A{  virtual ~A(){}; }; // 虚析构函数
    class B:public A{ virtual ~B(){};};  // 这个析构虽然名称不同但是还是会触发多态
    void func(A *ap) {  delete ap;}  // 如果传进来的是B(子类),会先调用B的析构然后再去调用A的析构.
                                     // 如果闯进来的是A(父类),就直接调用A 的析构函数了.
    // 虚析构函数的好处是: 函数在使用父类指针进行子类的传递的时候,可以在父类函数下直接进行delte , 
    //                  而且这个delte 会调用子类的,然后再去调用父类的.这样内存就不会泄露
    
! *父类中的析构函数 一定要写成虚构的, 以防止内存泄露!!**
! *子类的析构也要写成虚构的, 方便子类的下次继承.



____________________________________________________________________________________________
!重载 , 重写 , 重定义的区别: (重载发生在同作用域的普通函数之间,  重写.重定义发生在父类和子类两个类之间)
1 重载: 一定是同一个作用域下,(同名函数才会发生重载,也就是普通函数).
2 重定义: 是发生在两个不同的类中,一个是父类,一个是子类.
    (1).普通函数重定义:如果父类的普通成员函数(没有virtual),被子类重写,说是重定义.(默认为子类,需要作用域才能调用父类函数).
    (2).虚函数重写(也就是重写): 如果父类的虚函数,被子类重写,就是虚函数重写,这个函数会发生多态.(函数头必须一模一样).
3 重写: 也是发生在两个不同的类中,一个是父类,一个是子类,函数必须是虚函数,才可以发生重写.(也就只能是类了).
_____________________________________________________________________________________________

多态 : (面向对象编程的核心,真正要使用的东西),
! 如果有几个相似而不完全相同的对象,有时人们要求在向他们发出同一个消息时,他们的反应各不相同,分别执行不同的操作.这种情况就是多态.
! 多态发生的三个条件:
        1),要有一个父类,拥有一个(纯)虚函数. 
        2),子类一定要继承这个父类,重写这个(纯)虚函数.(在父类的成员方法前加 virtual, 来构成虚函数).       
        3),通过父类指针指向子类对象,进行调用.
        
! 多态的意义就是:你可以写一个架构来调用未来的代码,通过原有的功能或架构来调用一个新功能的类.

    
class one{          //定义了一个类, 他是父类
 public:
    one(string num){        //一个构造函数
        this->num = num;
    }
    
    virtual void print(){    //这是个方法,父类的虚构函数(virtual关键字在起作用),也就是可以重定义的,对比默认构造和显示构造
        cout << " 编号 num = " << num <<endl;         //显示构造后,编译器默认给的构造就被隐藏了
    }
    
    string num;     // 为了方便把他放在了公有成员内,如果是private的话将还应该在写个返回他的值的公有函数就好了.
};


class two:public one{    // 一个子类,他的父类是 one(我不打算给他增加子类,所以不添加 virrtual)
public:
    two(string num):one(num){}    //调用父类的构造函数去初始化 num ,如果num是父类私有成员,那么只能通过父类的构造去赋值.

    virtual void print(){    // 重写了虚函数 print(), 虽然内容一样 ,但还是算重写,这个关键字虽然在这里没作用但是还是写上好
        cout <<" 编号 num = " << num << endl;     
    }
};


class three:public one{   //一个子类 ,他的父类是 one (也不打算给他另一个子类)
public:
    three(string num):one(num){}   // 还是调用 one 的构造函数,如果num是父类私有成员,那么只能通过父类的构造去赋值.
    
    virtual void print(){    // 重写了虚函数 print(), 虽然内容一样 ,但还是算重写, 这个关键字虽然在这里没作用但是还是写上好
        cout <<" 编号 num = " << num << endl;  
    }
};

void COUT(one* prt){   //写在全局的一个架构函数,形参是父类的指针,(只能是父类的指针或引用)
    cout << "显示编号" << endl;
    prt->print();    //调用的是传入进来的形参的成员函数.
}

int main(void){   // 开始主函数
    one* ONE = new one("一号");   // 这是父类 给了他 一号
    two* TWO = new two("二号");   // 这是子类 给了他 二号
    three* THREE = new three("三号");  // 这是子类 给了他 三号
    
    COUT(ONE);    // 会打印 : 显示编号 编号 num = 一号
    COUT(TWO);    // 会打印 : 显示编号 编号 num = 二号
    COUT(THREE);  // 会打印 : 显示编号 编号 num = 三号   : 结束
                  // 这就是多态,使用虚函数来进行重载,如果不添加 virtual将会出现如下输出
                  // 显示编号 编号 num = 一号
                  // 显示编号 编号 num = 一号
                  // 显示编号 编号 num = 一号   : 结束
   // 全都变成了父类中的内容,也就是说调用的是子类中的父类那部分的print() 这个成员函数,而不是子类自己定义的.
}  //  结束   懒得写 delete 了    //此代码可以直接粘贴运行测试.


! 代码中如果不添加 virtual 为什么会变成这样呢?
    这是因为编译器默认做了一个安全处理,编译器不管传递子类对象还是父类对象,如果统一执行父类的方法,那么一定可以被成功执行.
    这个时候子类的那个同名成员函数就被忽略了.
! 如果想要在将来重载的成员函数,尽量都写上 virtual 关键字,无论基类或者继承类(为了健壮性).
! 只要是通过父类的的指针,并且重载修改子类中父类的虚函数来达到成员的添加,只要继承一个父类那么就可以随便添加一个接口的各种状态.
! 不光成员函数可以变成虚函数,析构函数也可以变成虚析构函数.而且还避免了内存泄漏,所以还是要写上 virtual ~A(){} .来析构.
! 多态对于编译器来讲,也是一个动态联编,也是一个迟绑定.


========
多态的原理: (借助虚函数表和vptr指针来实现)

1). 如果说一个类有 virtual 虚函数关键字的时候, 在编译器开辟空间的时候,会默认增加一个指针,vptr.(在内存中所有成员的前面).
2). 这个指针会指向一个虚函数列表(这个表存在常量区,代码段或bss段),里面存放了所有 virtual 修饰的成员头指针(函数,析构等等).
3). 当定义父类指针来使用子类类型来开辟内存空间后,(父类*p = new 子类;). // 只能这样来申请指针,指向子类中父类的那一部分.
    调用父类和子类虚函数列表中的某一个函数的时候,会先从子类的虚函数表中开始寻找,
    如果没有找到会再去父类的虚函数表中查找,这时如果找到就会输出父类表中的虚函数.
4). 如果没有在表中找到,那么代表父类和子类的虚函数表中都没有相对应的虚函数,这个时候就从父类中查找(因为指针停留在了父类中)
    普通函数成员,如果匹配则输出,如果没有匹配的则回到子类,继续寻找,如果还是没有,那么就报错失败.
    



    class fu{ //父类开始, 为了方便就不写构造和析构以及私有成员
    public: 
        virtual void add(int a){cout << "fu::virtual add(int).." << endl;}   // 在父类虚函数表中
        virtual void add1(int a,int b){cout << "fu::virtual add1(int,int).." << endl;} // 在表中
                void add2(int a,int b,int c){cout << "fu::add2(int,int,int).." << endl;}  //不在表中
     };  //父类结束                                                     //最后一个是父类作用域中的函数
     class zi:public fu{  // 子类开始,继承父类
     public:        // 在这个子类中(没有下一个子类了),不需要 virtual
        void add(int a){cout << "zi::add(int).." << endl;}  //覆盖了父类析构函数
        void add1(int a,int b){cout << "zi::add1(int,int).." << endl;} // 覆盖了父类虚构函数
        void add2(int a,int b,int c){cout << "zi:add2(int,int,int).." << endl;} //子类作用域中的函数
    };  // 子类结束      //因为父类也有最后这个成员,所以触发重定义,(子类指针时隐藏父类),(父类指针时忽略子类)
    
    int main(void){     // 主函数开始
        fu* fup = new zi;    // 父类的指针fup 指向子类中父类的那一部分,,在堆上申请内存空间.
        fup->add(10);       //输出 zi::virtual add(int).. 父类虚构函数被子类同名同形参的覆盖掉了,然后输出子类
        fup->add1(10,20);    //输出 zi::add1(int,int).. 父类虚构函数被子类同名同形参的覆盖掉了,然后输出子类
        fup->add2(10,20,30); //输出 fu::add2(int,int,int).. 父类中的这一部分并不是虚构函数,
        // 父类指针会从 子类中查找与 父类的虚函数表内 相同的函数,一旦发现子类中有重定义的,则使用子类的函数,隐藏掉父类中的虚构函数, 又因为是父类指针指向了子类,所以直接忽略其余子类中特有的所有成员.
        

        zi* zip = new zi;    // 子类的指针zip 指向子类,  在堆上申请内存空间.
        zip->add(10);        // 输出 zi::add(int)..         虚构函数父类成员被隐藏
        zip->add1(10,20);    // 输出 zi::add1(int,int)..    虚构函数父类成员被隐藏
        zip->add2(10,20,30); // 输出 zi::add2(int,int,int). 重定义了父类中的函数,显示子类中的 
        cout << sizeof(fu) << endl << sizeof(zi) << endl;   // 会返回 8 ,因为有个this指针和vpte指针       
    } // 重载 对普通函数有效(只能同作用域重载,不包括跨类重载).
      // 重定义 对跨类中函数有效(只能对函数名相同,返回值相同,形参相同的两个不在同作用域内的父类和子类起作用).
      // 重写 仅仅对两个父类和子类中的虚函数起作用.
    
! 重载,重定义,重写,  是整个多态原理的关键中的关键!!!!!
! 当类中声明虚函数时,编译器会在类中生成一个虚函数表.
! 虚函数表是一个存储类成员函数指针的数据结构.
! 虚函数表是由编译器自动生成与维护的.
! virtual 成员函数会被编译器放入虚函数表中.
! 存在虚函数时,每个对象都有一个指向虚函数表的指针(vptr指针).这个指针会存在类中,占用4或8个字节(无论多少个虚函数,只能有一个指针)
! 相同的函数,父类是普通函数,子类是虚函数,那么父类指针访问的是父类的,子类指针访问的是子类的,不存在反向继承访问.

____________________________________________________________________________________________
!重载 , 重写 , 重定义的区别: (重载发生在同作用域的普通函数之间,  重写.重定义发生在父类和子类两个类之间)
1 重载: 一定是同一个作用域下,(同名函数才会发生重载,也就是普通函数).
2 重定义: 是发生在两个不同的类中,一个是父类,一个是子类.
    (1).普通函数重定义:如果父类的普通成员函数(没有virtual),被子类重写,说是重定义.(默认为子类,需要作用域才能调用父类函数).
    (2).虚函数重写(也就是重写): 如果父类的虚函数,被子类重写,就是虚函数重写,这个函数会发生多态.(函数头必须一模一样).
3 重写: 也是发生在两个不同的类中,一个是父类,一个是子类,函数必须是虚函数,才可以发生重写.(也就只能是类了).
_____________________________________________________________________________________________

继承类中的 vptr 指针分布初始化: 
    vptr指针是分布初始化的.
    如果初始化一个父类的指针去指向一个子类,那么在调用父类的构造器的时候,会将 vptr 指针当作父类来处理.此时会临时指向父类
        的虚函数表.
    将子类对象的空间变成子类对象处理, vptr 指针就从指向父类的表 变成 指向子类的表. 
     (不应该在构造函数中出现业务,也就是调用其他的函数成员之类的,初始化就是初始化).
    
    在调用父类的构造函数时,vptr指针会指向父类的虚函数表,一旦父类初始化完成,则指针转而指向子类的虚函数表.
    有多少个父类,那么 vptr指针就需要转换多少次,毕竟一旦类中有虚函数表,那么vptr指针就会指向他. 
     

如何证明 vptr指针的存在方式:
    定义一个类,不包含 virtual 关键字的任何函数,然后使用 sizeof() 来查看类的大小,
    随后将 virtual 关键字添加到类中,再次使用 sizeof() 来查看大小,
    这时的类的大小就会比原先的值增加4个字节(如果是64位 则增加 8个字节).
    

------------------------------------------------------------------------------------------


纯虚函数:  (虚函数的语法: virtual 类型 函数名 (参数表) = 0;   //固定格式 没有解释 )

! 纯虚函数的意义:就是为了让子类去继承我,然后来重写我.(他不需要任何实现的,没有含义,仅仅是一个接口).
! 无论一个类有多么的复杂,有多少的成员, 一旦他出现了 纯虚函数 那么他就是抽象类.

! 纯虚函数是一个在基类中声明的虚函数,在基类中没有定义,要求任何派生类都定义自己的版本.
! 纯虚函数为每个派生类提供一个公共界面( 接口的封装和设计, 软件的模块功能划分).
! 如果说一个类拥有一个纯虚函数,就说这个类是一个抽象类.不管这类有没有成员属性,有没有私有成员,只要这个类有纯虚函数,那么这个类就是
    一个抽象类,抽象类就是并不能够实例化,就算实例化也没有意义.(就是不能定义抽象类的对象).
! 如果说一个普通类,继承拥有纯虚函数的类,那就必须要重写这个纯虚函数, 如果不重写纯虚函数,那么这个普通类依然是一个抽象类.依然不能
    被实例化,如果向实例化, 那么必须重写这个纯虚函数.(有几个纯虚函数,就必须重写几个纯虚函数).
! 抽象类和普通类的区别是: 一个不可以实例化,一个可以实例化.


~~! 设计模式经常使用这个春虚函数变成接口,降低了代码之间的耦合度,一定要分层次,要可拓展,架构师就是设计纯虚函数的~~
! 纯虚函数是一个面向抽象类编程的概念.
! 正确的纯虚函数架构应该存在如下的规范:
        1). 存在若干个纯虚函数.
        2). 存在正常的构造函数.且构造函数内不允许出现非初始化的语句.
        3). 必须存在纯虚析构函数. 以方便子类进行接口调用(一般是触发了子类的析构的时候就会自动触发抽象类的纯虚析构函数).
        
        


--------------------------------------------------------------------------------------------
抽象类:

! 一旦拥有一个或多个纯虚函数的类,那么这个类就是抽象类.
! 抽象类不能够实例化,也没有意义来实例化,因为纯虚函数没有函数体,没有实现,仅仅只是个接口,供子类来重写的.



面向抽象层编程:

! 依赖倒转,可以解决依赖层和 main() 函数之间的耦合度的减少.
! 可以无关联的其他东西,只写自己的,我只是根据我的抽象层进行编写,我不关心其他什么东西存在.
! 这么写完之后对我的维护度也很高,意义就是拓展性很强,每在增加一个新的实例化,都非常简单,只要继承抽象层就可以了.
! 拓展性很强,耦合度很低,对业务层(main()), 实现层解耦合的作用.

--------------------------------------------------------------------------------------------------------


静态联编和动态联编:  (作为了解就可以了)
! 联编是指一个程序模块,代码之间相互关联的过程.
! 静态联编(static binding),是程序的匹配,连接在编译阶段的实现,也成为早期匹配. 重载函数使用静态联编,(因为确定了).
! 动态联编(Dynamic binding),是指程序联编推迟到运行时进行,所以又称为晚期联编(迟绑定). switch 和 if ,多态 都是动态联编的例子.
!  c 和 c++  都是静态联编型语言.

    int a = 10;
    if ( a == 10){}   // 那怕这么写, 在 a 绝对等于10 的情况下,if也会是静态联编,也会运行进行判断和选择.
    else {};          // 不会出现编译时就直接确定的情况, 这个时候两个选项的内容都会被编译.


------------------------------------------------------------------------------------------



