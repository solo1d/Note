本笔记内的关键字:  都是重点内容(毫无水分)全部要掌握!
template  , friend , virtual  , operator  ,private  ,protected, public  ,
模板关键字, 友元   ,  虚和纯虚, 重载操作符,私有成员 ,保护成员 , 公有成员,

cerr    , clog    , ios::out , ios::app ,  ios::in , ios::binary , fstream.close(),
标准错误, 标准日志, 覆盖输出 , 添加输出 ,  只读模式, 二进制模式  ,   关闭文件    ,

throw , try, catch
异常处理

static_cast, dynamic_cast, const_cast,reinterpret_cast
强制类型转换运算符.

cin.get(无参数)  ,cin.get(一个参数), cin.get(两个参数), cin.getlen(), cin.ignore()
一次只能读一个字符,    读一个字符     , 可以读字符串     , 
cin.peek(), cin.putback()



1. 操作符是嵌在每一条指令中的，换句话说，指令系统的每一条指令都有一个操作符。是计算机系统中的术语。
    如=（赋值），==（判断相当），+，- 等等。

2. 运算符是数学中的术语。主要是指数之间的运算方式。
    如 + - * / %，但不包括 = （赋值）这样的操作符。

win 下的 Ctrl + z 就是 EOF.


! 在编写类模板的时候,类模板和函数模板分开两个文件来写,那么要把.cpp变成.hpp ,声明 .h 不变, 但是在使用的时候,
    要引用.hpp,不要引用.h, 这样才不会报错(.hpp 去引用.h), 而且.hpp 一般用来标识这个文件里面是类模板.
! 函数模板和 普通函数的区别是 : 普通函数会进行自动类型转换, 但是函数模板却严格检查类型,不会自动转换.
! 在定义一个类模板的对象的时候,必须要显示初始化( CLASS<int> object; //定义一个int类型的类对象)

! 函数模板是在编译的时候确定要生成什么样的实例化的函数,而不是在链接之后的时候!!!(而且还是以单文件为基准).
! 在C++编译器中, 普通函数的选择优先级 比 函数模板要高.(先查询普通函数,如果没有,才会调用模板函数).
! 二次编译. 第一次编译其模板(不会出现具体函数,只有调用的时候才会生成具体的函数),函数声明也不会编译.
          第二次编译模板的时候,会查看在本文件中有没有调用他的函数,如果有就生成,没有就不生成.
          (但是 如果在其他文件中调用这个函数模板,那么将会失败,因为找不到通过模板实例化的函数)
          和c++ 独立编译有关系, 这些东西都卡在 连接器那里 也就是 .o 到 .out 的过程中.

---------------------------------------------------------------------------------------------
! 函数模板标准格式:
    template<class T>     // 也可以这么写 template<typename T> , 多类型的话就添加 class T,class A,
    void MySwap(T& a,T& b);   // 把 T 替换    

    MySwap(10,20);              // 1 使用自动类型推导 
    MySwap<double>(3.1, 5.3);   // 2 使用显示指定类型  
    MySwap<>(10,20);           // 这样写可以防止被同名函数重载, 让编译器强制调用函数模板.(类型匹配的)
    

! 模板有调用两种类型: 1 自动类型推导, 2 显示的指定类型. 
! 使用函数模板的时候,编译器会根据你传的值,进行自动类型推导.
! 使用模板的时候,函数模板可以自动类型推导(不加<>尖括号就是自动推导), 但是类模板是不可以自动类型推导的.
! 函数模板不会进行自动类型转化,而是严格的类型匹配,(普通函数会进行隐式自动类型转化, 这点要注意!!).
! 函数模板可以像普通函数一样被重载,(就好比两个同名函数,一个是模板一个是普通函数, 一样都可以发生重载).
! C++编译器会优先考虑和调用普通函数,如果普通函数没有匹配的类型,才会考虑模板类型.!!!
! 函数模板是不能进行直接调用的,而是通过这个模板来实例化(生成)与传入类型相配的具体函数.


---------------------------------------------------------------------------------------------
! 类模板的标准格式:
    template<class T>   //这个T 非函数T, 而是替代了类内的某个类型而以.
    class Person{
    public:
        Person(T a, T b){
            this->a = a;
            this->b = b;
        }
        
        void Show(){
            cout << a << b << endl;
        }
        
    private:
        T a;
        T b;
    };

    int main(void){
        Person<double>pr(10.3,20.4);   //这样来使用类模板, 使T 变成了 double
        pr.Show();      
    }


! 函数模板在调用的时候,可以自动类型推导,类模板必须显示指定类型.(比如: Person<int>pr; 就是添加<> 尖括号,).


---------------------------------------------------------------------------------------------
index.cpp 编译流程: (这是个普通的源文件)
index.cpp -> 通过 预编译器 -> index.i (只是把需要的头文件之类的放入一个文件内,把宏定义展开和替换).
index.i   -> 通过 编译器   -> index.s 汇编文件 
index.s   -> 通过 汇编器   -> index.obj (linux是.o)  目标文件
index.o   -> 通过 链接器   -> index.exe 执行文件 (找到调用函数的函数实现).

$ g++ -E index.cpp -o index.i     // 该命令会生成 index.i 通过预编译
$ g++ -S index.i   -o index.s     // 该命令会把 .i 文件编译成 index.s 汇编文件.
$ g++ -c index.s   -o index.o     // linux下是.o  win 下是.obj   ,该命令会生成目标文件
$ g++ index.s      -o index       // 链接不需要命令, 直接就可以把.s 文件写在上面, 生成执行文件.


---------------------------------------------------------------------------------------------
类模板中的友元函数和普通函数声明和重载: ( 这是个坑 ,尽量不要用)
    
template<class T>class Pre;  //首先开始声明
template<class T>void Pre_FRIEND(Pre<T>& p);  // 这是普通友元函数声明
template<class T>ostream& operator<<(ostream& os, Pre<T>& p);  // 友元重载


template<class T>   // 类模板开始
class Pre {
public:
    Pre(T& a, T& b);  // 写在外部 构造函数

    void print();  //写在外部 普通函数

    friend void Pre_FRIEND<T>(Pre<T>& p); //写在外部 普通友元函数

    friend ostream& operator<< <T>(ostream& os, Pre<T>& p);  // 写在外部 友元重载操作符

    ~Pre(); //写在外部 析构函数
private:
    T a;
    T b;
};
    
template<class T>   //要注意 T 的次数  哪个都不能少
Pre<T>::Pre(T& a, T& b) {  //构造函数
    this->a = a;     //函数体没变化
    this->b = b;
}


template<class T>
void Pre<T>::print() {  //普通函数
    cout << "xxxx" << endl;  //函数体没变化
}
template<class T>
void Pre_FRIEND(Pre<T>& p) { //友元函数
         //函数体没变化
}
template<class T>
ostream& operator<<(ostream& os, Pre<T>& p) {  //友元重载操作符  注意T
    os << "a " << p.a << ", b " << p.b << endl;  //函数体没变化
    return os;
}

template<class T>
Pre<T>::~Pre() { //析构函数
        //函数体没变化
}


!!!!! 一定要注意 函数名和各个地方的 template 和 calss T   和 T 的位置和次数,  非常重要.
! 如果类模板和函数模板分开来写的话, 要引用函数模板实现的文件,不要使用.h, 而且把实现文件改为 .hpp 给主函数.
! 类模板中如果出现 static 成员,那么每一种实例化都会有自己单独的一个static 的值,和其他的实例化不相同.
! 派生类的时候也要具体化,就算派生类也是模板的话,也要具体化( template<class T>class SU:public Pre<T>{})

---------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------

类型转换:
    类型转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方法,
    为了类型转换一个简单对象为另一个对象你会使用传统的类型转换操作符.
    
    c 风格的强制类型转换,不管什么是什么类型,统统都是 Type b = (Type)a;  (不会进行类型检查)
    c++ 风格的类型转换提供了 4 种类型转换操作符来因对不同场合的应用.    (会对类型进行检查)
    
    
    
C++ 风格的强制类型转换关键字(运算符):
    static_cast   一般的转换,用在内建基础数据类型,指针和引用.   (会有类型检查)
    (是运算符)        用于,内置的数据类型,还有具有继承关系的引用和指针.
                    
    dynamic_cast  通常在 基类 和派生类之间进行转换时使用,有继承关系的. 动态类型转换
    (是运算符)       只能转换具有继承关系的指针或者引用, 只能由子类型转换到父类型.
                   
    const_cast    主要针对 const 的转换,只能对指针,引用.或者对象指针,增加const引用或者去掉const.
    (是运算符)       转化之前会做安全检查,(绝对不可以对对象使用,可以借助指向对象的指针或引用)
                    
    reinterpret_cast  用于进行没有任何关联之间的转换,比如字符指针转换为整形数.(跟c差不多).
    (是运算符)          没有安全检查,什么都能转, 比如class指针 转成函数指针.
     
范例: (实际使用的语法都差不多,只是传入参数不相同)

// 基础数据类型
    int  a  = 97;
    char c  =  static_cast<char>(a);   // 是基础类型可以转换
    char c1 =  dynamic_cast<char>(a);  //该转换会报错, 不可以转换 非指针或引用的类型
    cout << c  << endl;      // static_cast 转换后会输出一个字符 a  (ascll 码97就是a)

    const int& ca = a;
    int& ca1 = const_cast<int&>(ca);   // 可以转换,而且去除了const ,可以通过ca1进行修改了.
    ca1 = 30;                          //  通过ca1 修改了a 的值,但是不可以直接对a 进行赋值
    
    int* p =NULL;
    const int* p1 = const_cast<const int*>(p);  // 这样也是可以的,但仅仅p1具有const
    *p = 30;                           //虽然p1 指针具有const效应, 但是p 没有变,他还是可以修改.
   
       
// 基础数据类型指针或引用
    int*   p = NULL;
    char* sp = static_cast<char*>(p);   // 这样转换是会报错的,无法编译

    
//对象指针 和 引用
    class A{};              // A 是C 的父类
    class B{};              // B 无继承
    class C: public A{};    // C 继承 A
    A* a1 = NULL;
    B* b1 = NULL;
    C* c1 = NULL; 
    
    A* a2 = static_cast<A*>(b1);  // 错误的转换,无法转换的类型,因为他们没有继承关系
    B* b2 = static_cast<B*>(a1);  // 父类指针可以转换为子类指针 (不安全)
    C* c2 = static_cast<C*>(a1);  // 子类指针可以转换成父类指针  
    A* a3 = dynamic_cast<A*>(c1);   // 子类转换为父类的指针是可以的 不会出现内存访问越界
    B* b3 = dynamic_cast<B*>(c1);   // 错误的转换,两个毫无关系的类 是无法进行转换的
    C* c3 = dynamic_cast<C*>(a1);   // 错误的转换,父类转换子类内存会越界,dynamic_cast 会直接报错
    
    A a;
    B b;
    C c;
    
    A& a3 = a;   //正常的引用
    C& c3 = c;
    C& c4 = static_cast<C&>(a3);  // 父类引用可以转换为子类引用 (不安全)
    A& a4 = static_cast<A&>(c3);  // 子类引用也可以转换为父类引用
    

! 程序员必须清楚的知道要转变的变量,转换前是什么类型,转换后是什么类型,以及转换后有什么后果.
! 一般情况下,不建议类型转换,避免进行类型转换.
    
    
    
---------------------------------------------------------------------------------------------

容器 STL 基本概念:
    1. 对象元素必须能够被拷贝.
    2. 容器都是值寓意, 而非引用寓意. 向容器中放入元素,都是放入的元素的拷贝份.
    3. 如果元素的成员有指针,注意深拷贝的浅拷贝问题.



---------------------------------------------------------------------------------------------

异常机制:   <非常非常重要>
1.异常跨函数.
2.异常必须处理.


// 基础的语法:
    int divide(int x,int y) throw(int,float,char)       // 后面这个 throw 是异常接口声明.
    {                     // 显示这个函数只能抛出三种异常,其他的程序就宕掉,就当成给人看的.
        int a ;         // 当抛出异常的时候, 这个在栈上的值会被析构.无论他有没有被使用.         
        if( y == 0){            // 因为被除数不能为0 , 所以要判别.
            throw y;            // 发现被除数为0, 通过关键字 throw 抛出异常,跳出函数,回到上层.
        }
        return x/y;             // 如果无异常则正常的返回.
    }
    
    void test01(){   // 后面没有throw 表示这个函数可以抛出任何异常.
        try{                    // 下面执行的函数可能会出现异常,使用 try 关键字来接受异常.
            divide(10,0);       // 执行这个函数,      如果上面没有抛出异常,那么就忽略下面.
        }catch(int &e){          // 通过关键字 catch 来捕获异常.e 会得到抛出的值.(类型要匹配)
            cout << "除数为 " << e <<endl;      // 解决方案
        }catch(float &d){        // int的结束, 向下执行.捕获 float 的异常
            cout << "处理float" << endl;     //处理float的异常 
        }catch(...) {           //这里语法特殊有三个点,表示 捕获所有异常,填补上面没有匹配
            cout <<"未知类型异常" <<endl;     // 到的未知异常
        }
    }
    
   void stre throw (){   // 后面的这个 throw 没有参数,表示这个函数绝对不可以抛出任何异常.
       cout << "这个函数不可以抛出任何异常" <<endl;       
   }
    
    
    
    class obj{};  //这里面拥有一个构造函数.
    void return_class_obj(){
        throw obj();  // 普通对象接收 一个匿名对象
        throw obj();  // 引用接收    一个匿名对象   (尽量都要使用引用来进行)
        throw new obj(); // 指针接收  这里必须new 一个对象,否则会直接被析构,从而调用失败
    }
void ming(){
try{      
    return_class_obj();  //测试生命周期 返回一个类对象,  这里面拥有一个构造函数.
}catch(obj A){      // 生命周期的顺序是,拷贝构造,异常处理 .catch结束后-析构A,再析构函数抛出的对象.   
    cout<< "使用普通元素去接收抛出的异常"<<endl;
}catch(obj& B){     // 生命周期的顺序是  异常处理 .catch结束后-析构函数抛出的对象.
    cout<< "使用引用去接收抛出的异常"<<endl;
}catch(obj* C){     // 生命周期的顺序是  异常处理 .catch结束后-析构函数抛出的对象.
    cout<< "使用普通元素去接收抛出的异常"<<endl;
}
}
    
        
! 有的时候抛出的异常没有进行处理,编译也不会出错,但是运行的话会程序会直接崩溃.
! throw 抛出来的异常都是有类型的,可以是数字,字符串,类对象.
! throw 的异常是有	类型的, catch 需严格匹配异常类型.

! 使用 普通类型元素, 引用, 指针 三种方法接受抛出的异常的时候,这三种生命周期如下:
    普通类型元素: 创建一个普通类型元素,拷贝抛出的元素, catch处理完之后就析构,然后析构抛出的元素.
    引用 : 不用创建元素和构造,也不用拷贝,直接异常对象处理,处理之后把抛出的元素析构.
    指针 : 如果是new 的对象返回,那么和引用相同.  如果是一个普通元素返回,要防止这个返回对象提前析构.
    

! 如果异常抛到顶层,还没有处理,这个时候程序会挂掉,就是调用 terminate() 这个函数来终止程序.
! c++的异常机制会跨函数, 如果抛出一个异常当前函数没有处理函数,那么往回查找,直到找到或崩溃.
! c++的异常必须要处理,绝对不能留下, 一旦没有处理那么程序会直接崩溃.
! 异常抛出后,从进入 try 块开始,到异常被抛出前,这期间在栈上构造的所有对象,都会自动析构,析构的
    顺序与构造的顺序相反,这一过程称为 栈解旋 (unwinding).
! 一旦异常抛出,那么他会玩命的往回寻找 catch 定义的捕获他抛出的值的位置,期间经过的所有的在栈
    上的所有内容都会被析构.

---------------------------------------------------------------------------------------------
异常使用实例:  
! 需要引用头文件 <stdexcept> 来包含一个异常处理类,多人开发就用这个.
! 引用头文件之后,再继承这个文件中的异常处理类,重载 what() 来进行异常输出.(还可以添加别的).

class My_out_of_ramge:public exception{
    virtual const char* what() const throw(){   // 必须这么写,不能缺少关键字,否则报错
        return "错误信息";
    }
};

//也可以自己定义异常基类 , 也就是抽象类
class BaseMyException{
public:
	virtual void what() = 0;            // 这是最简单的类了
	virtual ~BaseMyException(){}        // 析构必须写
};



// -------------------------一套完整的范例---------

class BaseMyException{          // 抽象类接口
public:
	virtual void what() = 0;
	virtual ~BaseMyException(){}
};

class TargetSpaceNullException:public BaseMyException{  //子函数 继承了基类
public:
	virtual void what(){
		cout << "目标空间为空" << endl;
	}

	~TargetSpaceNullException(){
	}
};

class SourceSpaceNullException:public BaseMyException{  // 子函数  继承了基类
public:
	virtual void what(){
		cout << "源空间空间为空" << endl;
	}
	~SourceSpaceNullException(){
	}
};

void copy_str(char* taget, char* source){   // 拷贝函数
	if(taget == NULL ){
		throw TargetSpaceNullException();
	}
	if(source == NULL){
		throw SourceSpaceNullException();
	}

    *taget = *source;
	while(*source != '\0'){
		source++;
		taget++;
		*taget = *source;
	}

}


int main(void){
	char source[9] = {"abcdefg"};
	char buf[1024] = {0};
	
	try{
		copy_str(buf,source);
	}catch(BaseMyException& e){         // 这里只写抽象类就可以实现多态
		e.what();
	}

	cout << source << endl;
	cout << buf << endl;

	return 0;
}



! 在写可能会出现错误的函数的时候 就不要胡乱抛出了, 直接抛出类对象就好了,非常方便, 用多态.
! 有的地方不允许出现异常抛出,那么要多多注意,把在他前面的所有异常统统搞定就能正确进行了.
! 函数后面出现 throw()  括号里面什么都没有的话,就表示这个函数不允许出现任何的异常抛出.(但可以处理异常).
! 函数后面出现 throw(int,char)  括号里面出现的参数,就表示这个函数有可能会抛出这些类型的异常.
! 函数后面出现 const 表示不允许修改传入的参数.
! try 中的 catch() 的括号内 ,最好传入类型的引用, 这样比较好处理,而且不会犯错,(不要轻易传入指针).
! try 中的 catch() 的括号内, 如果传入的是一个类对象,那么他会调用类的拷贝构造,一定要提前把拷贝和=号都写好.



---------------------------------------------------------------------------------------------

c++的 输入流 和 输出流 以及 缓冲区:

! 输入和输出  是相对程序而说的.   输入输出的核心就是程序. 所有的输入输出都是程序来控制的.
! 键盘输出数据到程序,  称为标准输入  input
! 程序数据输出到显示器, 称为标准输出  ouput
! 标准输入 + 标准输出 = 标准 I/O
! 文件的输入和输出就叫文件I/O
! 缓冲区就是从内存开辟的一块空间而已.(可以看成一个 char buf[1024] 这样的数组).
! 输入缓冲区.存在于键盘和程序之间,由键盘输入数据,然后程序来这里读取数据. 键盘的回车就相当于刷新缓冲区.
! 输出缓冲区.存在于显示器和程序之间, 程序输出数据到缓冲区,然后刷新缓冲区后,缓冲区曾经的数据才会发送给显示器显示
! 在键盘(标准输入设备) 到 程序之间有个输入缓冲区的存在,程序会到缓冲区中拿数据,如果缓冲区内没有数据,那么程序
    会阻塞,等待键盘进行输入,  如果缓冲区有数据, 那么就会从缓冲区读入字符.


cout;  //全局流对象  输出数据到显示器
cin ;  //全局流对象  输入数据到程序
cerr;  // 标准错误   输出数据到显示器  没有缓冲区  因为没有缓冲区,那么数据会直接发送给显示器马上输出.
clog;  // 标准日志   输出数据到显示器  拥有缓冲区  有缓冲区,数据会存在缓冲区,等待刷新后才会发送给显示器.
endl;  // 刷新缓冲区  用来刷新缓冲区,把数据发送出去.以便下次写入新数据.


! 标准输入流 经常使用的类成员函数:
cin.get(无参数)    // 一次只能读取一个字符. 该字符会变成返回值, ch = cin.get();
cin.get(一个参数)  // 读一个字符.  和无参数一样. cin.get(ch);
cin.get(两个参数)  // 可以读一个字符串. 括号内第一个参数是字符数组,第二个参数是读取最长的长度.
                   //     而且不会读入换行符\n .  cin.get(buf,1024);  // 以换行为结尾和刷新
                   
cin.getlen(字符串,想要读取字符的数量)   // 从缓冲区读取一行放入字符串,但是这一行不能超过设定的数量.
                                        //    不会读取 换行符 '\n' 的.

cin.ignore(一或二个参数或无参数)  // 忽略当前字符 ,每次从缓冲区取走一个扔掉.这个成员函数有三种方式.
           cin.ignore()         // 忽略一个字符,从缓冲区取走一个扔掉. 无参数
           cin.ignore(20)       // 忽略连续的20个字符,从缓冲区取走20个字符扔掉 , 一个int 参数.
           cin,ignore(10,'\n')  // 忽略连续的10个字符,如果提前碰到 \n 则终止,无论是否取走够10个.
           
cin.peek(无参数)   // 偷窥一下缓冲区的第一个字符,并返回这个字符,但是不会从缓冲区取走字符.只是看一下.

cin.putback(必须是char)   // 把一个字符放回到缓冲区的第一个位置,(无论这个缓冲区是否修改过) 
                          // 应该配合 cin.get()使用. 取走一个就放回去一个.


                          
! 标准输出流 经常使用的类成员函数:
cout.flush(无参数)     // 刷新缓冲区,立刻显示
cout.put(一个字符)     // 向缓冲区内写入一个字符, 可以支持链式编程. cout.put('a').put('b').put('c');
cout.write(字符串,字符串大小)    //向缓冲区写入一串字符串,并且写入字符串大小(strlen(串)  不用+1).



! 格式化输出 经常使用的类成员函数: <重点内容>                
cout.unsetf(ios::dec);      // 卸载当前的十进制输出方式      ios::dec 表示十进制输出格式
cout.setf(ios::oct);        // 使用八进制进行输出            ios::oct 表示八进制输出格式
cout.setf(ios::showbase);   // 把 0x1 02 进制符号显示出来    ios::hex 表示十六进制输出格式

cout.width(数字);       // 设置输出位宽,每次输出的都必须占用设定长度的位置,没有则使用空代替
cout.fill(一个字符);    // 将输出长度的空变成这个字符, 要配合 cout.width() 来使用,来填补空缺,默认右对齐
cout.setf(ios::left);   // 左对齐方式输出.
cout.setf(ios::right);  // 右对齐方式输出。

cout << hex     // 通过控制符输出,需要引用头文件<iomanip>  这表示要用十六进制输出
     << setiosflags(ios::showbase)    // 显示十六进制和八进制的符号位  01  0x1 前面的0和0x
     << setw(10)    // 设置输出位宽, 输出长度为10 , 如果不填充则用空代替.
     << setfill('*')   // 使用 * 来代替位宽中的空缺.
     << setiosflags(ios::left)    // 左对齐方式输出
     << number      // 输出一个int 的 number
     << endl;       // 结束 回车
     

! 想要使用一种格式进行输出的话,最好卸载另外的几种不需要的格式. 比如想用八进制输出,那么卸载十和十六.
! 要注意, 如果在某个位置卸载了 十进制输出 ,而且又装载了十六或八进制输出格式的话,那么他下面的所有cout
    输出都会都会变成 十六或八进制, 除非再次装载十进制,而且卸载八或十六进制.(默认输出是十进制).
! 使用控制符进行输出的话,也会对下面所有的输出进行影响,不光光是调用它的这一行或是函数,而是整个程序.   



---------------------------------------------------------------------------------------------
文件的读写, 文件流类和文件流对象:

! 需要引用头文件 < fstream >
! ifstream 打开文件,读取文件,
! ofstream 打开文件,写入文件,


----------------- 打开和读取和写入文本文件--------------------

! 打开文件的两种方式 : (都是类对象)
    const char* fileName  = "C:/Users/28623/Desktop/soutce.txt";  // 需要读取的文件.
    const char* TagetName = "C:/Users/28623/Desktop/target.txt";  // 需要写入的文件.
    
    1. ifstream ism(fileName,ios::in);   //只读方式打开文件, ios::in  是读取打开方式
       ofstream osm(TagetName,ios::out); //以写的方式打开文件,ios::out 写入方式会覆盖文件原内容
                   (TagetName,ios::app); // 以添加打开文件,会从文件末尾开始写入,不会删除原内容. 
               (TagetName, ios::binary); // 以覆盖写入加二进制模式打开文件
      (TagetName, ios::binary|ios::app);  // 以添加模式加二进制打开文件(这个最好).
      
      
    2. ifstream ism;      ism.open(fileName,iso::in);       // 同上 
       ofstream osm;      osm.open(TagetName,ios::out);

// 打开后判断是否打开文件
    if( !ism )   // 要用取反来判断, 因为这个符号已经重载了 
    {   cout<< "打开文件失败" << endl;  throw ism;  //出现异常} 
    
~ 这么写只能从文件中读取内容到程序,不可以修改文件中的内容
    
    
! 读文件到屏幕,  一个字符一个字符的输出:
    char  ch ;   // 暂时保留读取到的字符
    while( ism.get(ch) ){    // 判断是否读取到文件末尾, 使用 .get(ch) ,把读取到的内容赋值给ch
        cout << ch;     // 输出字符到屏幕
        osm.put(ch);    // 输出字符到文件
    }        


! 关闭文件:
    ism.close();   // 调用 fstream 类中的成员函数 .close() 来关闭这个对象打开的文件.
    osm.close();
    

! 正常的文本修改和读取和c差不多,只不过都变成了对象和类成员了.

! 文本模式和二进制模式的区别就体现在win下,需要自动转换,但是linux却不需要.
! 文本模式打开win下文件,会自动把文件末尾的 "\r\n" 自动转换成 "\n"输入到程序中,但是把程序中的内容
    输入到文件中的话,就会把 "\n" 换成 "\r\n" 写入文件,这就是win下文件的读写.
! linux 文本模式或者二进制模式读取和写入文件都没什么区别.因为它就是"\n" 来当做行结尾的.不用转换.
! 二进制读写就是把内存中的内容原封不动的写入文件.
    
! ios::in  只读方式打开文件,   ios::out  以覆盖写入模式打开文件, ios::app 以在末尾添加模式
! ios::binary   二进制模式 


--------------- 二进制文件操作, 对象序列化 ------------------
! 对象序列化: 把类对象写入文件内,或者从文件内读取到程序内.

class Person {          //这是个普通类
public:
    Person() {}
    Person(int age, int id) :age(age), id(id) {}
    void Show() {
        cout << "Age: " << this->age << ",ID: " << this->id << endl;
    }
    ~Person() {}
public:
    int age;
    int id;
};

void test02() {
    //------把类对象的内存二进制数据,完整的写入文件中----
    Person p1(10, 20), p2(30, 40);
    // 把p1和p2写入文件. 这些数据在系统中都是二进制存在的.

    const char* TagetName = "C:/Users/28623/Desktop/target.txt";

    ofstream osm(TagetName, ios::out |ios::binary);  // 以二进制的写入模式打开
    osm.write((char*)&p1, sizeof(Person));    // 把p1的内存,完整的写入文件
    osm.write((char*)&p2, sizeof(Person));    // 把p2的内存,完整的写入文件
    // 因为 osm.write() 需要一个char* 类型参数和空间大小的参数,所以要强转类型

    osm.close();        // 关闭文件

    //------从文件读取内容放入到类对象中----
    ifstream ism(TagetName, ios::in | ios::binary);  // 以二进制的只读模式打开

    Person ps1,ps2;
    ism.read((char*)&ps1, sizeof(Person));
    ism.read((char*)&ps2,sizeof(Person));  //从文件读取数据放入到 p中
    // 因为 osm.read() 需要一个char* 类型参数和空间大小的参数, 所以要强转类型
    
    ps1.Show();
    ps2.Show();
};


 

! 正常的文本修改和读取和c差不多,只不过都变成了对象和类成员了.

! 文本模式和二进制模式的区别就体现在win下,需要自动转换,但是linux却不需要.
! 文本模式打开win下文件,会自动把文件末尾的 "\r\n" 自动转换成 "\n"输入到程序中,但是把程序中的内容
    输入到文件中的话,就会把 "\n" 换成 "\r\n" 写入文件,这就是win下文件的读写.
! linux 文本模式或者二进制模式读取和写入文件都没什么区别.因为它就是"\n" 来当做行结尾的.不用转换.
! 二进制读写就是把内存中的内容原封不动的写入文件.
    
! ios::in  只读方式打开文件,   ios::out  以覆盖写入模式打开文件, ios::app 以在末尾添加模式
! ios::binary   二进制模式 
 
! 使用linux的话,应该用二进制来进行读写操作最为方便和安全.


---------------------------------------------------------------------------------------------
