/* 适配器模式 就是将已经写好的接口, 但是这个接口不符合需求, 将写好的接口转换成目标接口. */#include <iostream>#include <vector>#include <algorithm>using namespace std;struct MyPrint{    void operator()(int v1, int v2 ){  // 这个接口并不是那么的适合下面的代码,需要适配        cout << v1 + v2 << endl;    }};// 定义目标接口  , 我要适配成什么样的class Target{public:    virtual void operator()(int v) = 0;};//写适配器class Adapter: public Target{public:    Adapter(int param){        this->param = param;    }    virtual void operator()(int v) {        print(v,param);    }public:    MyPrint print;    int param;};//MyBind2ndAdapter MyBind2nd(int v){    return Adapter(v);}/*_Function for_each(_InputIterator __first, _InputIterator __last, _Function __f){    for (; __first != __last; ++__first)        __f(*__first);    return __f;}*/int main(void){        vector<int> v;    for(int i = 0; i < 10 ; i++){        v.push_back(i);    }        for_each(v.begin(),v.end(),MyBind2nd(10));    // 这里的思维是 在运行for_each之前, 会先运行 MyBind2nd(10);,然后类开始构造, 返回一个类对象.    // 然后调用了 __f(*__first);  伪函数,print(v,garam); 然后再次调用 另一个两个函数的伪函数.                return 0;}