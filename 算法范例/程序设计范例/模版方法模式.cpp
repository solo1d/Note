/*  模版方法模式: 定一个操作中算法的框架,而将一些步骤延迟到子类中.    模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤. */#include <iostream>#include <vector>#include <algorithm>using namespace std;// 抽象类, 冲咖啡,冲茶叶 等等的步骤抽象class DrinkTemplate{public:    virtual void BoildWater() = 0;  // 煮水    virtual void Brew() = 0;  //冲泡    virtual void PourInCup() = 0 ; // 倒入杯中    virtual void AddSomethin() = 0;  // 加入辅料    // 模版方法    void Meke(){   // 定义了步骤的顺序        BoildWater();        Brew();        PourInCup();        AddSomethin();    }};// 冲泡咖啡class Coffee:public DrinkTemplate{public:    virtual void BoildWater(){  // 煮水        cout << "煮山泉水..."<< endl;    }    virtual void Brew(){  //冲泡        cout << "冲泡咖啡" << endl;    }    virtual void PourInCup(){ // 倒入杯中        cout << "把咖啡倒入杯中" << endl;    }    virtual void AddSomethin(){  // 加入辅料        cout << "加糖,加牛奶,加点醋" << endl;    }};// 冲泡茶水class Tea:public DrinkTemplate{public:    virtual void BoildWater(){  // 煮水        cout << "煮自来水..."<< endl;    }    virtual void Brew(){  //冲泡        cout << "冲泡铁观音" << endl;    }    virtual void PourInCup(){ // 倒入杯中        cout << "把茶水倒入杯中" << endl;    }    virtual void AddSomethin(){  // 加入辅料        cout << "加糖,加柠檬,加生姜..." << endl;    }};void test01(){    DrinkTemplate* tea = new Tea;    tea->Meke();        cout << endl;    tea = new Coffee;    tea->Meke();        delete tea;}int main(void){            test01();        return 0;}