


线程池是自定义的操作, 一般不需要程序猿来写, 都是使用项目提供的函数来操作.

|-----------------------------------------------------------------|
|    消费者     |       生产者         |         生产者              |
|    线程池     |       server        |         客户端              |
|--------------|   |------------|    |                            |
|   最大线程数   |   |            |    |                            |
|   最小线程数   |   | |--------| |    |         客户端              |
|              |   | | 任务队列 | |   |                             |
|  存活的线程数  |   | |--------| |    |                            |
|  干活的线程数  |   |            |    |                            |
|              |   |------------|    |    线程阻塞条件 - 任务队列已满 |
|   默认步长:   |                     |    阻塞客户端往任务队列中扔数据 |
|    一次+n个   |        消费者        |                            |
|    一次性-n   |                     |                            |
|--------------|--------------------------------------------------|





线程阻塞条件:
    任务队列如果为空, cond_empty
            pthread_cond_wait( &cond_empty, &mutex );


    任务队列中有数据:   
        激活阻塞在条件变量上的线程:
            pthread_cond_signal( &cond_empty);
            pthread_cond_broadcast( &cond_empty);

                1. 初始化一些线程
                2. 需要有一个管理者线程, 只能有一个
                     a. 如果使用率超过一定的百分比
                        i. 创建线程: 按照一定的步长增涨,但是不能超过线程最大值

                     b. 空闲的线程增多
                        i. 销毁线程
                            留下的比实际多一些

                3. 线程工作的时候:
                     a. 处理数据的时候:
                        i. 互斥锁
                        ii. 条件变量



管理者线程 要做的事情:
    - 计算线程是否够用 
         不够用, 创建线程
    - 空闲线程太多
         销毁条件阻塞的没有工作的线程:
            更新要销毁的线程个数
            通过条件变量完成的:
                如果空闲太多, 任务不够:
                    线程阻塞在该条件变量上.
                发送信号:
                    pthread_cond_signal


线程池中的线程, 也就是工作线程:
    - 从任务队列中取数据
        任务队列中的 任务个数--
        执行任务
    - 销毁空闲的线程
        让线程自己执行 pthread_exit()
        阻塞空闲的线程收到信号.
            解除阻塞
            只有一个往下执行
            在执行任务之前销毁操作
                自行退出.






