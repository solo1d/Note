gcc  工作流程 :    c i s o out
    预处理 -  E   ( gcc -E file) xx.c -> xx.i { 宏替换, 头文件展开, 注释去掉, 形成 c 文件 ,调用预处理器 }
    编译   -  S   ( gcc -S file) xx.i -> xx.s { 把代码转换成汇编格式, 形成汇编文件 ,调用gcc }
    汇编   -  c   ( gcc -c file) xx.s -> xx.o { 形成二进制文件 ,调用as 汇编器 }
    链接   -  无  ( gcc    file) xx.o -> xx.out { 可执行文件 , 调用ld 链接器 }

编译过程最费时间.
gcc 只做了两个事情, 一个是调用其他的处理器, 一个是把c 编译成汇编文件. 
(作用是 按照某种规则来编译代码)

gcc 常用参数:
    -v     显示版本    
    -I     编译的时候指定头文件的路径.     gcc file.c -I ./include/ 
    -c     将一个汇编.s 文件生成 .o 文件.  gcc file.s -c -o newfile.o
    -o     指定生成的文件名字.             gcc file.c -o newfile.out
    -g     gbd 调试的时候需要加, 但是生成之后的文件较大.
    -D     在编译的时候指定一个宏.  gcc file.c -D DEBUG    (DEBUG是文件中的一个宏控制,测试用)
    -Wall  显示警告信息.
    -On    优化代码. n 是优化级别:1,2,3 (最高等级是3).  gcc file -O1 
    -l     指定 动/静 态库的名字. (如果动态库文件名是 libxxx.so  ,那么就写成 -lxxx  就可以了).
    -L     指定静态库文件存在的路径.        gcc file.c -L ./lib/ -lmya
        -m32  编译一个32位的程序. (-m64 就是64位,默认是64)
                    (需要 sudo apt-get install gcc-multilib g++-multilib module-assistant )




------------------------------------------------------------------------ 
------------------------------------------------------------------------ 
 静态库加载到内存的地址是固定的(使用的是绝对地址),动态库加载到内存的地址是不固定的(使用的是相对地址).
    运行时,需要调用的动态库会被加载到共享区 的内存空间中, 如果不需要某个动态库中的函数,那么这个动态库不会加载.

 什么是静态库和动态库?     二进制的源代码
 能干什么?   加密,保护知识产权, 缩减源代码文件个数.
 怎么用?     静态库(生成.o ,打包ar, 编写测试文件) , 动态库(生成.o -fpic ,打包gcc -shared ,环境变量)
 




静态库的制作和使用:  (编译后可删除,与运行无关)
    gcc -c mya.c -o mya.o  ;   // 先制作函数的 .o 文件,提供给ar 使用
    ar rcs libmya.a mya.o  ;   // 打包, 制作结束

    gcc main.c  -L ./lib/ -lmya -o main.out ;  // 使用静态库, 把libmya.a 放入lib文件夹内.(编译后可删除)

    nm libmya.a     ;   // 查看静态库内的内容.


    详解:
        命名规则:
             .lib - 库的名字 (win下).  libtemp.lib
             .a   - 库的名字 (unix下). libtemp.a
        制作步骤:
                1 .需要有源代码 mya.c    (不需要main函数)
                 将 mya.c  生成 mya.o文件          gcc -c mya.c -o mya.o  -I ./include/头文件所在地
                2. 然后将 mya.o 打包,使用命令ar      ar rcs  libmya.a mya.o
                 得到了静态库文件. 然后把 libmya.a 和 mya.h 头文件给用户就可以了.

             使用 nm 可以得到libmya.a中的内容.  nm libmya.a     
                    会罗列出来.

        使用静态库: (拥有库和头文件,库放在lib ,头文件放在include)
                gcc main.c -I ./include/ -L /lib/ -l mya -o main.out 

                -L 指定库的路径.
                -l 指定库的名字,去掉lib 和 .a  剩下的就是文件的名字 .
                        mya 是 libmya.a 这个文件 去头去尾后的名称.


静态库优点:
      静态库被打包到应用程序中 ,加载速度快.
      发布程序无需提供静态库.
静态库缺点:
      浪费系统资源,浪费内存.
      更新,部署,发布麻烦, 每次更新都需要重新编译,哪怕小改动也要大更新.



------------------------------------------------------------------------ 

动态库的制作和使用:
        gcc  -c  *.c  -fpic ;
        gcc  *.o  -shared   -o libxxx.so;  // 制作完成

        gcc main.c -I ./include/ -L ./ -l xxx   -o app ;  //使用
        vim ~/.bashrc    ; // 打开后添加  export LD_LIBRARY_PATH=动态库的绝对路径
        source ~/.bashrc ; // 重新读取这个配置文件.   结束.



    详解:
        命名规则: 
                libxxx.so
        制作步骤:
                1. 将源文件生成 .o ,但是需要添加额外参数 -fpic :  
                        gcc a.c b.c -c -fpic ;  // 得到 a.o 和 b.o 两个文件  

                2. 打包成动态库. 只添加了一个额外参数 -shared 
                         gcc a.o b.o -shared -o libxxx.so  ;  //这里必须要改名

        使用:
                1 参考头文件中的函数声明来,编写测试程序. main.c
                2 gcc main.c -I ./include/ -L ./ -l xxx   -o app ;

        动态库无法加载解决方案 3 种方法:
            一  使用环境变量:
                        临时设置: 
                                在终端: 
                                     export LD_LIBRARY_PATH=动态库的绝对路径:$LD_LIBRARY_PATH
                                                             (不要出现空格,仅在这个终端有效,关闭就失效).
                        永久设置:
                                用户级别: 
                                     ~/.bashrc   (在文件内添加这行 export LD_LIBRARY_PATH=动态库的绝对路径 )
                                             添加完成后 输入命令 source ~/.bashrc  .(或者重新打开终端)

                                系统级别: 
                                     /etc/profile  (在文件内添加这行 export LD_LIBRARY_PATH=动态库的绝对路径 )
                                             添加完成后 输入命令 source /etc/profile  .(或者重启系统)
         
            二  永久设置: /etc/ld.so.cache 文件列表:
                          找到一个配置文件
                                /etc/ld.so.conf 
                                    然后将动态库的绝对路径添加到文件中.  /home/pi/a/lib
                                然后执行一个命令:   sudo ldconfig -v
                 
            三  dlopen   打开动态库 函数;
                dlclose  关闭动态库 函数;
                dlsym    调用动态库 函数;

            
动态库优点: 
      可实现进程间的资源共享.
      程序升级简单.
      程序员可以控制何时加载动态库.
动态库缺点:
      加载速度比静态库慢.
      发布程序需要提供依赖的动态库.


------------------------------------------------------------------------ 
------------------------------------------------------------------------ 

------------------------------------------------------------------------ 
------------------------------------------------------------------------ 


gdb 调试  , 在没有IDE 的情况下才会使用gdb.
    gcc a.c b.c -g -o app
    -g 会保留函数名和变量名. (如果没有-g 那么程序里面只有地址,没有变量名和函数名).
    
启动gdb命令:
    gdb 可执行程序的名字
 a. gdb app
 b. 给程序传参:  (gdb) set args  需要传入的参数  回车
                (gdb) r        // 这一个r  是运行,

 c. 查看文件内容: (gdb) l                   // 默认显示20行. 如果再次按下回车,就会再次执行l 命令.
                 (gdb) show listsize 行数     // 默认显示行数的个数设置.
                 (gdb) set listsize  20       // 修改默认显示行数, 变成20行.
                 (gdb) l 20                // 显示15到25行的内容,  这个20是个中间值.
                 (gdb) l  函数名            // 显示从函数名的上下10行 .
                 (gdb) l  文件名:行号或者函数名   // 可以显示任意文件中的函数.

 d. 断点调试: 不要在注释和大括号的行号打断点, 那个位置是无效断点.
        插入断点:和设置条件断点.
                (gdb)  b  行号或者函数名  // 在行号那行插入断点,
                (gdb)  b  行号  if 断点条件  //条件断点, 只有 if 得到与条件相匹配的时候才会停下.
                (gdb)  b  文件名: 行号或函数名   // 在文件中的某个函数或者某个位置插入一个断点.
        显示断点:
                (gdb)  i  b              // 显示设置过的断点, num是编号,Enb中 y是有效 n 无效,后面是行号.
        删除断点:
                (gdb)  d  断点编号         // 删除 编号为2的断点, 可删除多个.
                (gdb)  d  编号1-断点5      // 范围删除, 编号内的断点全部都删除,包括 1和5.
        断点生效和无效:
                (gdb)  dis  断点编号    // 将编号的断点设置为无效, Enb 中变成n .
                (gdb)  enb  断点编号    // 将编号的断点设置为生效, Enb 中变成y .
                
        程序运行:
                (gdb)  r       // 运行程序, start 也能行,但是还是需要 c 来继续下去.
                (gdb)  c       // 继续运行,直到下个断点或者结束,在r的基础和断点的基础上执行.
                (gdb)  n       // 向下单步调试,程序走一行代码, 需要断点模式.  遇到函数不会进入函数体内部.
                (gdb)  s       // 向下单步调试, 遇到函数会进入函数体内部.
                (gdb) finish   // 跳出函数体. 如果有断点就无法跳出,  除非删掉或无效化断点.
                (gdb) until    // 跳出循环,   如果有断点也无法跳出, 也需要删除和无效化断点.
                
        打印变量的值:
                (gdb)  p  变量名        // 打印一次变量的值.
                (gdb)  ptype 变量名     // 打印一次变量的类型.
                (gdb)  display 变量名   // 每次单布运行都会打印变量的值.
                (gdb)undisplay 编号    // 取消 dispaly 的效果.不会每次都打印了, i display 来获得编号.
                (gdb)  i display      // 会得到 dispaly 要求单布调试都会打印的值的编号列表.
                
         调试的时候直接设置变量的某一个值
                (gdb)  set var 变量名=某个值     //修改变量的值,直接篡改内存中的值,小心使用.
        退出调试: 
                (gdb) q      // quit


