fork(),  getpid(), getppid(), kill(), execl() ,execlp(), wait(), waitpid(), 
pipe(), fifo(), 
mmap(), munmap(),
<unistd.h> , <sys/wait.h> , <sys/mman.h> , <fcntl.h>



掌握 fork / getpid / getppid 函数的使用, ps / kill 命令的使用, execl / execlp 函数的使用.
    wait函数的使用, waitpid 函数的使用.

sleep(number);   <unistd.h>    暂停函数,


程序和进程
    程序: 二进制文件, 占用的磁盘空间.  a.out 没有运行,放在磁盘上
    进程: 启动的程序, 占用的内存空间.  a.out 运行了, 加载到内存上  (运行后,就算删除了a.out, 进程还是正常走)

并行和并发
    并发: 一个时间段内,单核处理器所能处理的的请求以及运算.每个进程都会占用时间段内的一部分来运算,然后暂停换下个程序.
    并行: 就是多核处理器在同一个时间段内做同一件事情. (每个处理器都在做并发处理).





pcb (进程控制块)
    定义的位置在: LINUX: /usr/src/linux-headers-3.16/include/linux/sched.h  
              MAC OS : /usr/include/pthread/sched.h

    内容如下:
    
      pid(进程ID): 系统中每个进程有一个唯一的ID,在 C语言中用pid_t 类型表示, 其实就是个非负整数.(type unsigned int)
    
      进程的状态 : 有 就绪 , 运行 , 挂起 , 停止  , 初始 五个状态.
    
      进程切换时需要保存和恢复的一些CPU寄存器内容和状态.
    
      描述虚拟地址空间的信息.
    
      描述控制终端的信息. (运行时需要输入和输入,那么就要和终端打交道)
    
      当前工作目录 (Current working Directory)
    
      umask 掩码,  他用来做 mode & ~umask  文件权限.
    
      文件描述符表, 包含很多指向file结构体的指针. 可以看成是一个1024的数组, 每个进程最多可以打开1024个文件描述符.
    
      和信号相关的信息.  (这个信号是 linux 独有, windows 下没有这个)
    
      用户id 和组 id  (stat 文件,  会拿到文件的信息)
    
      会话(Session) 和进程组.  (多个有关联的进程会组成进程组, 多个有关联的进程组可以组成会话)
    
      进程可以使用的资源上限.  (通过ulimit -a 命令可以得到一部分资源上限的列表)

! 每个进程都有一个内核区, 每个进程的内核区里面都有一个进程控制块, 
  每启动一个进程,那么在内核区中的 进程控制块就会记录所有的内容.



进程的五种状态 : 就绪态, 运行态, 挂起态, 停止态, 初始态
    初始态, 就是 ./a.out 刚刚输入,程序正在向就绪态转换的过程.它是所有程序的起点.
    就绪态, 有执行资格,没有执行权限, 准备抢夺cpu资源,但是还没得到cpu.
    运行态, 有执行资格,有执行权限, 得到了cpu资源,而且cpu也正在运行他, 如果他失去cpu那么就会回到就绪态,继续准备.
    挂起态, 没有执行资格,没有执行权, 失去了cpu, 等待唤醒条件得到满足后就会拥有执行资格,回到就绪态,准备抢cpu.
    终止态, 程序被杀死, 所有的进程状态都可以直接变成终止态.

kill -9 pid    输入进程的pid 就可以杀死这个pid的进程,
pgrep  程序名   会获得程序的pid
pgrep  -       会得到一个pid列表,但是没有名称

-----------------------------------------------------------------------

执行程序所对应的 虚拟地址空间包括两个部分: 内核区和用户区
    内核区包含:   pcb(进程控制块);

    用户区包含:  堆 , 栈,   .text(代码区),  .bss (为初始化全局/静态区) , .data(已初始化全局/静态区)
               动态库加载区, env环境变量,   命令行参数 ;

-----------------------------------------------------------------------

<unistd.h>

fork  { 创建一个子进程  } 
    函数原型:   pid_t fork(void);  
        pid_t 返回值: 他会在两个进程中分返回不同的值.
                     父进程返回子进程pid ,说明现在是在父进程内.
                     子进程返回0  ,      说明现在是在子进程内.
                     创建失败返回-1,      说明现在是在父进程内

    子进程被创建后, 内核区的和用户区是完全拷贝父进程的内容,除了进程ID(就是pid) 不同之外,其他全部相同.
    
    执行位置:  子进程被创建后 
        父进程执行到了哪,子进程就从那个地方开始执行.
    
    执行顺序:
        子进程被创建后,子进程和父进程会同时执行,他们都会去抢夺cpu资源,执行的顺序和cpu 有关系. 用户无法控制,
    
    区分父子进程:
        父进程返回的是子进程的pid (大于0的正整数)  
        子进程返回的是 整数 0  


函数
getpid / getppid   { 得到当前/父进程的PID }
    函数原型 :     pid_t getpid(void);
                  pid_t getppid(void);

        getpid  返回值:  当前 进程的PID
        getppid 返回值:  当前 进程的 父进程的PID  (如果父进程比子进程提前结束,那么他会返回1)



bash命令   获得程序pid
ps  aux | grep  "程序名"    { 得到程序的 pid 和运行状态列表 }
ps  ajx | grep  "程序名"    { 得到程序的 pid 和父进程pid  ,比上个更详细 }



bash命令  给程序发信号
kill  -l             { 查看信号列表 ,列表中的前32个, 在所有系统中动作是相同的, 下面的不相同 }
kill  -9  "程序pid"   { 给pid 这个程序发信号,让他终止 (SIGKILL  用9 代替了)  }
pkill -f  "程序名"    { 根据程序名 杀掉程序 }

!( Ctrl/conttol  + c/z  这个操作只是挂起程序,让他去后台运行,并不是终止程序! )



  刚fork 出来之后:
     两个地址空间用户区数据完全相同.

     后续各自进行了不同的操作:
        各自进程的地址空间中的数据是完全独立的.互不影响.  ( 子进程和父进程不会执行相同的操作 )
    
    程序内的数据 只读时 共享一块内存.
    当子进程或父进程要修改数据时,会从内存中拷贝一份然后提供给子进程或父进程来使用,  以达到数据的绝对独立性.
    子进程和父进程所有的数据类型(包括全局变量),都不能共享.
    
    main 主函数的父进程的父进程是 bash 这个进程. 也就是前段终端, 它会成为运行程序的父进程.
    pid 为 0 的交换进程是 所有其他进程的祖先进程.



-----------------------------------------------------------------------


exec函数族   { 让父子进程执行互不相干的操作,   
              能够替换进程地址空间中的源代码,
              当程序中调用另外一个应用程序 首先想到 exec 之前需要 fork() 一个进程.
              返回值: 
                    如果函数执行成功, 不返回父进程.
                    如果函数执行失败, 手动打印错误信息, 退出当前子进程.
            }

-----
execl()     { 他会替换子进程内部的代码,并且执行传入参数指向的程序,而且也不会回到父进程的轨迹 }
    函数原型: 
      执行指定目录下的程序: int execl (const char* path, const char* arg, ...);

            path   参数: 要执行程序的绝对路径 ,(相对也行), 命令也可以执行,但是需要 /bin/目录下的.
            arg    参数: 随便写点什么,这个参数没用.
            后续的  参数: path执行程序的参数,可以有多个,需要分隔符,写完后必须以 NULL 为结束符号.
    
            返回值     : 程序或命令调用失败,则返回-1  ,但是这个返回值压根没用.
    
    一般用在启动自定义的程序上.而不是执行系统的内容. 比如启动一个自己编写的 a.out 之类的程序.
    
        例: pid_t pid = frok();
            if ( pdi == 0 ){
                execl("/Users/ns/a.out", "a.out", "传入1", "传入2", NULL);  // 执行成功则不执行 perror
                perror ("程序执行失败");                                    // 执行失败 则执行这里.
                exit(1);                   // 这里退出的是子进程,跟父进程无关.   不需要判断返回值,压根没用
            }
            // 调用a.out 然后传入两个参数给他.然后执行.  参数可以写在一起 ,也可以多次传入. 

----
execlp()    { 执行 PATH 环境变量能够搜索到的程序. 和execl 一样, 只不过他更适合来执行命令 ,而且不需要路径 }
    函数原型: 
        int execlp (const char* command , const char* arg, ... );

            command   参数: 执行的命令的名字.
            其余都和 execl 一样.
    
        使用方法也和 execl 一模一样.
    
        系统的命令一般都在 /bin: /usr/local/bin:    /usr/local/bin:    /usr/sbin:
                        /usr/local/bin:          /usr/bin: /bin:    /sbin
        PATH  个人设置参数在 ~/.bash_profile   在这个文件中.  



-----------------------------------------------------------------------


孤儿进程 : 父进程创建子进程.
          但是父进程先结束了,子进程还在存活, 这个子进程就被称为 孤儿进程.
          孤儿被 init 进程领养, init进程变成了 孤儿的父亲.
          init 这个操作是为了释放子进程占用的系统资源.
              正常进程结束之后, 能够释放用户区空间.
              但是孤儿无法释放 pcb ,必须由父进程释放.

僵尸进程 : 父进程创建子进程, 
          子进程先结束了,但是结束的不彻底, 父进程还在, 但是父进程没有去释放子进程残留的pcb ,
          子进程就变成了 僵尸进程.
          但是这个子进程是一个已经死掉的进程,只不过死的状态比较特殊.


进程回收:    { 如果想在程序里面通过父进程来回收子进程资源的话, 那么必须要使用 wait 或 waitpdi 其中的一个 } 



<sys/wait.h>
    wait()  - 这是个阻塞函数,他会等待子进程结束,然后进行回收,如果子进程没有结束,那么会一直阻塞父进程,不让其向下运行.

    函数原型 :   pid_t wait (int* status);
    
                status   参数: 判断子进程是如何死的. 如果对退出状态不关心的话可以写个 NULL,函数会修改传入的参数的值
                                   >0 表示正常退出.
                                   =0 被某个信号杀死了.
                         这个参数的具体修改依据是子进程正常结束时 return 和 exit() 的返回值.返回多少就设置成多少.
                         如果是被信号杀死的,那么也会返回信号的值 (32个其中的一个,或者系统自定义的更大的数).
    
                        子进程退出状态验证 -- 传入参数 (&status)
                            1. WIFEXITED(status);       返回非0 代表成功, 进程正常结束.
                                 WEXITSTATUS(status);   如果上一条宏返回非0, 那么这个会返回进程退出的状态.
                                                             也就是子进程 (exit(), return ) 的参数;
    
                            2. WIFSIGNALED(status);  返回非0 代表进程异常终止.
                                 WTERMSIG(status);  如果上一条宏返回非0 ,那么这个会返回进程终止的那个信号的编号.
                                                             也就是子进程是被( kill -9 或某个)杀死的.


                返回值:  -1 代表回收失败,  代表的是已经没有子进程了,所有的子进程资源都被回收了.
                        >0 已经回收的子进程的pid.


            调用一次只能回收一个子进程, 每调用一次就回收一次.而且那个子进程结束了,那他就回收哪个,无法指定回收.
    
              for(pid_t wpid,int ret; (wpid = wait(&ret)) != -1 ; )
              {
                printf("循环回收进程\n");
                if(WIFEXITED(ret))   { printf("正常退出 return 或exit 的返回值是 %d",WEXITSTATUS(ret)); }
                if(WIFSIGNALED(ret)) { printf("信号中断 信号编号是 %d",WTERMSIG(ret)); }
              }




<sys/wait.h>
waitpid       {}
    函数原型:   pid_t waitpid(pid_t pid, int* status, int options);

                pid  参数:  pid > 0  : 指定回收的某个子进程的pid.
                           pid = -1 : 回收所有的子进程.(但是每次也只是回收一个.)
                                       需要循环回收,  while( (wpid = waitpid(-1, &status, xx)) != -1 ) 
    
                status 参数: 判断子进程是如何死的. 如果对退出状态不关心的话可以写个 NULL,函数会修改传入的参数的值
                                   >0 表示正常退出.
                                   =0 被某个信号杀死了.
                         这个参数的具体修改依据是子进程正常结束时 return 和 exit() 的返回值.返回多少就设置成多少.
                         如果是被信号杀死的,那么也会返回信号的值 (32个其中的一个,或者系统自定义的更大的数).
    
                        子进程退出状态验证 -- 传入参数 (&status)
                            1. WIFEXITED(status);       返回非0 代表成功, 进程正常结束.
                                 WEXITSTATUS(status);   如果上一条宏返回非0, 那么这个会返回进程退出的状态.
                                                             也就是子进程 (exit(), return ) 的参数;
    
                            2. WIFSIGNALED(status);  返回非0 代表进程异常终止.
                                 WTERMSIG(status);  如果上一条宏返回非0 ,那么这个会返回进程终止的那个信号的编号.
                                                             也就是子进程是被( kill -9 或某个)杀死的.


                options 参数:
                          0       -  表示waitpid 会阻塞程序.
                          WNOHANG -  表示非阻塞
                返回值   : 
                           -1  : 回收失败,表示已经没有子进程结束需要回收了, (不包括正在运行的子进程)
                           >0  : 被回收的子进程的pid
                           如果为非阻塞, options 参数为 WNOHANG 的时候:
                                 =0  : 子进程处在运行状态.


      最常用的代码规范:     int status;   pid_t wpid;
                          while( (wpid = waitpid(-1,&status, WNOHANG)) != -1 ){
                              if(wpid == 0){ 
                                continue;     // 如果有子进程还活着就进入这里,等待子进程死亡
                              }
                              printf("... child died pid = %d\n",wpid);  // 已经死亡子进程id
                              if(WIFEXITED(status)){                    // 判断是不是正常结束
                                printf("return value %d\n",WEXITSTATUS(status));
                              }
                              else if(WIFSIGNALED(status)){             // 判断是不是异常结束
                                printf("died by signal: %d\n",WTERMSIG(status));
                              }
                          }

-----------------------------------------------------------------------


进程间通信相关概念:
    ipc : 进程间通信  (interProcess Commuication)

    进程间通信常用的四种方式 - 和特点
        a. 管道  - 最简单也最方便实现
        b. 信号  - 不好实现,但是调用的是系统函数,所以开销比较小
        c. 共享映射区   -  有无血缘关系的进程间通信都可以实现
        d. 本地套接字   -  稳定





pipe 管道 (匿名管道)    { 没有对应的磁盘文件 ,就算查看 大小也为0,它存在于内核的一块缓冲区内 }
    本质:  内核缓冲区 (就是一个伪文件,他不占用磁盘空间,操作方式和普通文件是一样的)
    特点:  
        内核缓冲区分为两部分(两端):  
            读端 和 写端 ,他们分别对应两个文件描述符.
            数据写端流入, 读端流出.
        操作管道的进程被销毁之后, 管道占用的存储空间就自动的被释放了.
        管道默认是阻塞的,  读操作和写操作全都是阻塞的.

    管道的原理 
        内部实现方式: 环形队列 的数据结构(对尾插入,对头输出,先进先出)
        缓冲区的大小: 默认是 4K ,(大小会根据实际情况做 适当 的调整).
    
    管道的局限性
        受限于 队列 的数据结构造成 :  数据只能读取一次, 不能重复读取. 
        半双工 : 
            单工: 遥控器  , 电视机只能接收, 遥控器只能发送.
            半双工: 对讲机 , 数据传输的方向是单向流动的.
            双工: 电话 , 双方都可以同时话说和听.
        匿名管道: 
            适用于有血缘关系的进程.  如果没有血缘关系 就不能使用匿名管道.
    
    创建匿名管道:
        int  pipe( int fd[2]);
           fd  -  传出参数
           fd[0] - 读端
           fd[1] - 写端
           返回值:  -1 表示失败.


    注意事项: 
        父进程读时   -- 父进程关闭写端
        子进程写时   -- 子进程关闭读端


管道的读写行为     { 管道默认是阻塞的 }
    读操作:
        管道内有数据 : read(fd) - 正常读,  返回读出的字节数
        管道内无数据 : 
                写端全部关闭    : read 解除阻塞, 返回0 , 相当于读文件时,读到了文件的尾部.
                写端没有全部关闭 : read 会阻塞, 等待管道被写入数据,然后读取出来.
    写操作:
        读端全部关闭  : 只有写操作会造成 管道破裂 , 进程被终止. 
                        这个时候内核会给当前进程发信号 SIGPIPE
        读端没全部关闭 : 
                缓冲区写满了 : write 阻塞,等待缓冲区内的数据被读端取走, 然后他在继续写.
                缓冲区没写满 : write 继续写,  等到缓冲区写满 就会阻塞, 这两个状态开始循环触发.
    设置为非阻塞:
        默认读写两端都阻塞.
        设置读端为非阻塞 pipe(fd)
            fcntl - 变参函数
                复制文件描述符 - dup
                修改文件属性 - open 的时候对应的 flag 属性.
            设置方法: 
                获取原来的 flag 的属性.
                int flags = fcntl(fd[0],F_GETFL); 
                
                // 设置新的 flags   
                flags |= O_NONBLOCK;  // 将这个属性加入到flags中
                fcntl(fd[0],F_SETFL,flags);    
                // 写上这三句话就可以把你的管道的读端或写端 给他设置成非阻塞的属性


查看管道缓冲区大小:
    命令:  
        ulimit -a 
    函数:
        long fpathconf(fd[0],_PC_PIPE_BUF);     // fd 是管道描述符 , 返回缓冲区大小. 最后参数不用修改.

--------------------------



fifo 管道 (有名管道)   { 在磁盘上有这样一个文件, 有阻塞 }
    特点: 有名管道
         在磁盘上有这样的一个文件, 如果使用 ls -l  来查看  会发现文件属性是 p , 大小为0
         也是伪文件, 在磁盘上大小永远为0 
         在内核中有一个对应的缓冲区, 数据就存放在缓冲区中.
         半双工的通信方式.

    使用场景:
        没有血缘关系的进程间通信.
    
    创建方式:
        命令 : mkfifo 管道文件名
        函数 : mkfifo(管道文件名, 该文件的八进制的权限)
    	返回0表示成功, -1 表示失败
    
    fifo 文件可以使用 IO 函数进行操作.
        open / close
        read / write
        不能执行 lseek 操作
    
    进程间通信过程伪代码:
        fifo 文件 -- myfifo
          两个不相干的进程  A(a.c), B(b.c)
          a.c - > read 操作
            int fd = open( "myfifo" , O_RDONLY );   //就给一个只读权限
            read(fd,buf, sizeof(buf));  // 如果管道内没有数据,那么就会发生阻塞,等到b.c 来写入.
            close(fd);
          b.c - > write 操作
            int fd1 = open( "myfifo" , O_WRONLY);
            write(fd1, "hello,world",11);
            close(fd1);



-----------------------------------------------------------------------


 内存映射区 :  { 实现无血缘关系进程的通信 , 没有阻塞 ,而且注意父子进程读写的顺序 ,但是他效率高,因为他操作的是内存 }

 <sys/mman.h>
    mmap   -- 创建内存映射 
        作用 :  将磁盘文件的数据映射到内存, 用户通过修改内存就能修改磁盘文件. 但是不能扩充文件大小,所修改的内容长度有限制.
     函数原型:  void* mmap(
                    void*  adrr,    // 映射区首地址, 一般传入NULL 就可以了.  
                    size_t length,  // 映射区的大小, 就是内存的大小, 一般为4k的倍数
                    int    prot,    // 映射区权限, PROT_READ 读, PROT_WRITE 写,用位操作 | 来设定多个权限  
                    int    flags,   // 标志位参数, MAP_SHARED 修改了内存数据会同步到硬盘, MAP_ORIVATE 不会同步
                    int    fd,      // 要映射的文件对应fd, 通过open 得到文件描述符
                    off_t  offset   // 映射文件的偏移量,  一般设置0就好.要么就必须是4k的倍数,否则报错.
                    )
             返回值: 调用成功返回映射区的首地址. 
                    调用失败返回一个宏(MAP_FAILED 可以当作if条件,其实就是一个 -1 ,),并且把error设置成一个合适的值.
                        if ( mmap返回值  == MAP_FAILED ) { 创建内存映射失败了 }

            想要实现内存映射区,那么必须要有一个文件.(这是一个绝对前提,如果没有,那么所有操作全部不成立)
            参数 prot 权限设定值,必须大于等于 open 文件时候的权限.
            不可以对文件大小为0 的文件进行内存映射, (就算是新文件,也尽量使用lseek来拓展文件,以防万一).
            只要映射区创建成功之后, 就算关闭文件描述符, 也没有影响.
            文件中的原有数据在单纯文件映射时有用, 进程间通信时,没用.仅仅起到桥梁作用.
            对内存的操作适用于内存映射区.(strcpy, strlen,strcmp,strcat,)


    munmap  -- 释放内存映射区
        作用 : 将 mmap 申请的内存释放掉
      函数原型:  int munmap(void* addr, size_t length);
                addr   参数: mmap 的返回值
                length 参数: mmap 的第二个参数,也就是内存大小.(要注意一定是4k 的倍数) 



进程间的通信:   (内存是没有阻塞的)
  有血缘关系的:

   使用 有名 内存映射区进行 有血缘关系的进程间通信
    父进程和子进程之间共享 : 文件描述符, 内存映射区.  
        使用 返回值 (void*) 来读写内存,实现通信.

   使用 匿名 内存映射区进行 有血缘关系的进程间通信, 不和任何文件发生关联
    int fd = open ("文件",打开方式);
    ftruncate(fd,4096);         // 一定要扩充文件.
    int len = lseek(fd, 0, SEEK_END);   // 求文件的大小.
    void * ptr = mmap( NULL, 内存大小, PROT_READ | PROT_WRITE , MAP_SHARED | MAP_ANON, -1 ,0 );
        // 必须这么写 ,增加了MAP_ANON权限 ,只有 PROT_WRITE 这个写入权限 依情况添加, 剩下的 就当内存来操作就行了.


  无血缘关系的: 

   只能使用 有名 内存映射区 进行 无血缘关系的进程间通信.
     两个无血缘关系的进程,都要打开同一个文件,同样操作mmap, 然后进行读写, 实现通信,(没有阻塞,要多多注意).
    
    读取内存进程:   
       int fd = open("文件",打开方式);
       size_t size = lseek(fd, 0, SEEK_END);  // 拿到文件大小
       lseek(fd, 0 , SEEK_SET);
       void* ptr = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
       while(1){
            sleep(1);
            printf("%s\n",(char*)ptr);
       }
       munmap(ptr,size);  colse(fd);
    
    写入内存进程:
        int fd = open("文件", 打开方式);
        size_t size = lseek (fd, 0, SEEK_END);
        lseek(fd, 0 , SEEK_SET);
        void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, fd, 0);
        while(1){
            char* p = (char*)ptr;
            strcpy(p, "通信内容");
            sleep(2);   // 比读取时间长
        }
        munmap(ptr, size);



-----------------------------------------------------------------------
